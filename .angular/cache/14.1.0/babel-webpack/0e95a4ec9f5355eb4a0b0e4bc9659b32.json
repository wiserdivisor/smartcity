{"ast":null,"code":"/**\n * @module ol/MapBrowserEventHandler\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport { PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { VOID } from './functions.js';\nimport { getValues } from './obj.js';\nimport { listen, unlistenByKey } from './events.js';\n\nvar MapBrowserEventHandler =\n/** @class */\nfunction (_super) {\n  __extends(MapBrowserEventHandler, _super);\n  /**\n   * @param {import(\"./PluggableMap.js\").default} map The map with the viewport to listen to events on.\n   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n   */\n\n\n  function MapBrowserEventHandler(map, moveTolerance) {\n    var _this = _super.call(this, map) || this;\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./PluggableMap.js\").default}\n     * @private\n     */\n\n\n    _this.map_ = map;\n    /**\n     * @type {any}\n     * @private\n     */\n\n    _this.clickTimeoutId_;\n    /**\n     * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n     * @type {boolean}\n     */\n\n    _this.emulateClicks_ = false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.dragging_ = false;\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n\n    _this.dragListenerKeys_ = [];\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent|null}\n     * @private\n     */\n\n    _this.down_ = null;\n\n    var element = _this.map_.getViewport();\n    /**\n     * @type {Array<PointerEvent>}\n     * @private\n     */\n\n\n    _this.activePointers_ = [];\n    /**\n     * @type {!Object<number, Event>}\n     * @private\n     */\n\n    _this.trackedTouches_ = {};\n    _this.element_ = element;\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n\n    _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n\n    _this.originalPointerMoveEvent_;\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n\n    _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayMoveEvent_, _this);\n    /**\n     * @private\n     */\n\n    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);\n\n    _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {\n      passive: false\n    } : false);\n\n    return _this;\n  }\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {\n    var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(\n      /** @this {MapBrowserEventHandler} */\n      function () {\n        this.clickTimeoutId_ = undefined;\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  };\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {\n    var event = pointerEvent;\n    var id = event.pointerId;\n\n    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[id];\n\n      for (var pointerId in this.trackedTouches_) {\n        if (this.trackedTouches_[pointerId].target !== event.target) {\n          // Some platforms assign a new pointerId when the target changes.\n          // If this happens, delete one tracked pointer. If there is more\n          // than one tracked pointer for the old target, it will be cleared\n          // by subsequent POINTERUP events from other pointers.\n          delete this.trackedTouches_[pointerId];\n          break;\n        }\n      }\n    } else if (event.type == MapBrowserEventType.POINTERDOWN || event.type == MapBrowserEventType.POINTERMOVE) {\n      this.trackedTouches_[id] = event;\n    }\n\n    this.activePointers_ = getValues(this.trackedTouches_);\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n    this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.preventDefault().\n\n    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n\n    if (this.activePointers_.length === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {\n    return pointerEvent.button === 0;\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {\n    this.emulateClicks_ = this.activePointers_.length === 0;\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n    this.dispatchEvent(newEvent); // Store a copy of the down event\n\n    this.down_ =\n    /** @type {PointerEvent} */\n    {};\n\n    for (var property in pointerEvent) {\n      var value = pointerEvent[property];\n      this.down_[property] = typeof value === 'function' ? VOID : value;\n    }\n\n    if (this.dragListenerKeys_.length === 0) {\n      var doc = this.map_.getOwnerDocument();\n      this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n      /* Note that the listener for `pointercancel is set up on\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n       * the `pointerup` and `pointermove` listeners.\n       *\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\n       * issues `pointercancel` events, when there was no `touchend` for a\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n       * But `documentPointerEventHandler_` doesn't know about the first\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n       * only registered there.\n       */\n      listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n\n      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n        this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n      }\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.updateActivePointers_(pointerEvent);\n      this.dragging_ = true;\n      var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);\n      this.dispatchEvent(newEvent);\n    }\n  };\n  /**\n   * Wrap and relay a pointermove event.\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.relayMoveEvent_ = function (pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));\n  };\n  /**\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n   * when an interaction (currently `DragPan` handles the event.\n   * @param {TouchEvent} event Event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events.\n    var originalEvent = this.originalPointerMoveEvent_;\n\n    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {\n      event.preventDefault();\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  };\n  /**\n   * Clean up.\n   */\n\n\n  MapBrowserEventHandler.prototype.disposeInternal = function () {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n\n    this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    this.element_ = null;\n\n    _super.prototype.disposeInternal.call(this);\n  };\n\n  return MapBrowserEventHandler;\n}(Target);\n\nexport default MapBrowserEventHandler;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","EventType","MapBrowserEvent","MapBrowserEventType","PointerEventType","Target","PASSIVE_EVENT_LISTENERS","VOID","getValues","listen","unlistenByKey","MapBrowserEventHandler","_super","map","moveTolerance","_this","map_","clickTimeoutId_","emulateClicks_","dragging_","dragListenerKeys_","moveTolerance_","undefined","down_","element","getViewport","activePointers_","trackedTouches_","element_","pointerdownListenerKey_","POINTERDOWN","handlePointerDown_","originalPointerMoveEvent_","relayedListenerKey_","POINTERMOVE","relayMoveEvent_","boundHandleTouchMove_","handleTouchMove_","bind","addEventListener","TOUCHMOVE","passive","emulateClick_","pointerEvent","newEvent","CLICK","dispatchEvent","clearTimeout","DBLCLICK","setTimeout","SINGLECLICK","updateActivePointers_","event","id","pointerId","type","POINTERUP","POINTERCANCEL","target","handlePointerUp_","defaultPrevented","isMouseActionButton_","length","forEach","button","property","value","doc","getOwnerDocument","push","handlePointerMove_","getRootNode","isMoving_","POINTERDRAG","dragging","originalEvent","cancelable","preventDefault","Math","abs","clientX","clientY","disposeInternal","removeEventListener"],"sources":["/home/asura/github/smartcity/node_modules/ol/MapBrowserEventHandler.js"],"sourcesContent":["/**\n * @module ol/MapBrowserEventHandler\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport { PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { VOID } from './functions.js';\nimport { getValues } from './obj.js';\nimport { listen, unlistenByKey } from './events.js';\nvar MapBrowserEventHandler = /** @class */ (function (_super) {\n    __extends(MapBrowserEventHandler, _super);\n    /**\n     * @param {import(\"./PluggableMap.js\").default} map The map with the viewport to listen to events on.\n     * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n     */\n    function MapBrowserEventHandler(map, moveTolerance) {\n        var _this = _super.call(this, map) || this;\n        /**\n         * This is the element that we will listen to the real events on.\n         * @type {import(\"./PluggableMap.js\").default}\n         * @private\n         */\n        _this.map_ = map;\n        /**\n         * @type {any}\n         * @private\n         */\n        _this.clickTimeoutId_;\n        /**\n         * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n         * @type {boolean}\n         */\n        _this.emulateClicks_ = false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.dragging_ = false;\n        /**\n         * @type {!Array<import(\"./events.js\").EventsKey>}\n         * @private\n         */\n        _this.dragListenerKeys_ = [];\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n        /**\n         * The most recent \"down\" type event (or null if none have occurred).\n         * Set on pointerdown.\n         * @type {PointerEvent|null}\n         * @private\n         */\n        _this.down_ = null;\n        var element = _this.map_.getViewport();\n        /**\n         * @type {Array<PointerEvent>}\n         * @private\n         */\n        _this.activePointers_ = [];\n        /**\n         * @type {!Object<number, Event>}\n         * @private\n         */\n        _this.trackedTouches_ = {};\n        _this.element_ = element;\n        /**\n         * @type {?import(\"./events.js\").EventsKey}\n         * @private\n         */\n        _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);\n        /**\n         * @type {PointerEvent}\n         * @private\n         */\n        _this.originalPointerMoveEvent_;\n        /**\n         * @type {?import(\"./events.js\").EventsKey}\n         * @private\n         */\n        _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayMoveEvent_, _this);\n        /**\n         * @private\n         */\n        _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);\n        _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);\n        return _this;\n    }\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n        if (this.clickTimeoutId_ !== undefined) {\n            // double-click\n            clearTimeout(this.clickTimeoutId_);\n            this.clickTimeoutId_ = undefined;\n            newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n            this.dispatchEvent(newEvent);\n        }\n        else {\n            // click\n            this.clickTimeoutId_ = setTimeout(\n            /** @this {MapBrowserEventHandler} */\n            function () {\n                this.clickTimeoutId_ = undefined;\n                var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n                this.dispatchEvent(newEvent);\n            }.bind(this), 250);\n        }\n    };\n    /**\n     * Keeps track on how many pointers are currently active.\n     *\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {\n        var event = pointerEvent;\n        var id = event.pointerId;\n        if (event.type == MapBrowserEventType.POINTERUP ||\n            event.type == MapBrowserEventType.POINTERCANCEL) {\n            delete this.trackedTouches_[id];\n            for (var pointerId in this.trackedTouches_) {\n                if (this.trackedTouches_[pointerId].target !== event.target) {\n                    // Some platforms assign a new pointerId when the target changes.\n                    // If this happens, delete one tracked pointer. If there is more\n                    // than one tracked pointer for the old target, it will be cleared\n                    // by subsequent POINTERUP events from other pointers.\n                    delete this.trackedTouches_[pointerId];\n                    break;\n                }\n            }\n        }\n        else if (event.type == MapBrowserEventType.POINTERDOWN ||\n            event.type == MapBrowserEventType.POINTERMOVE) {\n            this.trackedTouches_[id] = event;\n        }\n        this.activePointers_ = getValues(this.trackedTouches_);\n    };\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {\n        this.updateActivePointers_(pointerEvent);\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n        this.dispatchEvent(newEvent);\n        // We emulate click events on left mouse button click, touch contact, and pen\n        // contact. isMouseActionButton returns true in these cases (evt.button is set\n        // to 0).\n        // See http://www.w3.org/TR/pointerevents/#button-states\n        // We only fire click, singleclick, and doubleclick if nobody has called\n        // event.preventDefault().\n        if (this.emulateClicks_ &&\n            !newEvent.defaultPrevented &&\n            !this.dragging_ &&\n            this.isMouseActionButton_(pointerEvent)) {\n            this.emulateClick_(this.down_);\n        }\n        if (this.activePointers_.length === 0) {\n            this.dragListenerKeys_.forEach(unlistenByKey);\n            this.dragListenerKeys_.length = 0;\n            this.dragging_ = false;\n            this.down_ = null;\n        }\n    };\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @return {boolean} If the left mouse button was pressed.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {\n        return pointerEvent.button === 0;\n    };\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {\n        this.emulateClicks_ = this.activePointers_.length === 0;\n        this.updateActivePointers_(pointerEvent);\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n        this.dispatchEvent(newEvent);\n        // Store a copy of the down event\n        this.down_ = /** @type {PointerEvent} */ ({});\n        for (var property in pointerEvent) {\n            var value = pointerEvent[property];\n            this.down_[property] = typeof value === 'function' ? VOID : value;\n        }\n        if (this.dragListenerKeys_.length === 0) {\n            var doc = this.map_.getOwnerDocument();\n            this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), \n            /* Note that the listener for `pointercancel is set up on\n             * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n             * the `pointerup` and `pointermove` listeners.\n             *\n             * The reason for this is the following: `TouchSource.vacuumTouches_()`\n             * issues `pointercancel` events, when there was no `touchend` for a\n             * `touchstart`. Now, let's say a first `touchstart` is registered on\n             * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n             * But `documentPointerEventHandler_` doesn't know about the first\n             * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n             * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n             * only registered there.\n             */\n            listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n            if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n                this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n            }\n        }\n    };\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {\n        // Between pointerdown and pointerup, pointermove events are triggered.\n        // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n        // moved a significant distance.\n        if (this.isMoving_(pointerEvent)) {\n            this.updateActivePointers_(pointerEvent);\n            this.dragging_ = true;\n            var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);\n            this.dispatchEvent(newEvent);\n        }\n    };\n    /**\n     * Wrap and relay a pointermove event.\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.relayMoveEvent_ = function (pointerEvent) {\n        this.originalPointerMoveEvent_ = pointerEvent;\n        var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n        this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));\n    };\n    /**\n     * Flexible handling of a `touch-action: none` css equivalent: because calling\n     * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n     * when an interaction (currently `DragPan` handles the event.\n     * @param {TouchEvent} event Event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {\n        // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n        // may not be initialized yet when we get here on a platform without native pointer events.\n        var originalEvent = this.originalPointerMoveEvent_;\n        if ((!originalEvent || originalEvent.defaultPrevented) &&\n            (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {\n            event.preventDefault();\n        }\n    };\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @return {boolean} Is moving.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {\n        return (this.dragging_ ||\n            Math.abs(pointerEvent.clientX - this.down_.clientX) >\n                this.moveTolerance_ ||\n            Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_);\n    };\n    /**\n     * Clean up.\n     */\n    MapBrowserEventHandler.prototype.disposeInternal = function () {\n        if (this.relayedListenerKey_) {\n            unlistenByKey(this.relayedListenerKey_);\n            this.relayedListenerKey_ = null;\n        }\n        this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n        if (this.pointerdownListenerKey_) {\n            unlistenByKey(this.pointerdownListenerKey_);\n            this.pointerdownListenerKey_ = null;\n        }\n        this.dragListenerKeys_.forEach(unlistenByKey);\n        this.dragListenerKeys_.length = 0;\n        this.element_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return MapBrowserEventHandler;\n}(Target));\nexport default MapBrowserEventHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}