{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Draw\n */\n\n\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, { fromCircle, makeRegular } from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { always, noModifierKeys, shiftKeyOnly } from '../events/condition.js';\nimport { boundingExtent, getBottomLeft, getBottomRight, getTopLeft, getTopRight } from '../extent.js';\nimport { createEditingStyle } from '../style/Style.js';\nimport { fromUserCoordinate, getUserProjection } from '../proj.js';\nimport { getStrideForLayout } from '../geom/SimpleGeometry.js';\nimport { squaredDistance as squaredCoordinateDistance } from '../coordinate.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n */\n\nvar Mode = {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  POLYGON: 'Polygon',\n  CIRCLE: 'Circle'\n};\n/**\n * @enum {string}\n */\n\nvar DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\n\nvar DrawEvent =\n/** @class */\nfunction (_super) {\n  __extends(DrawEvent, _super);\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n\n\n  function DrawEvent(type, feature) {\n    var _this = _super.call(this, type) || this;\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n\n\n    _this.feature = feature;\n    return _this;\n  }\n\n  return DrawEvent;\n}(Event);\n\nexport { DrawEvent };\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\n\nvar Draw =\n/** @class */\nfunction (_super) {\n  __extends(Draw, _super);\n  /**\n   * @param {Options} options Options.\n   */\n\n\n  function Draw(options) {\n    var _this = this;\n\n    var pointerOptions =\n    /** @type {import(\"./Pointer.js\").Options} */\n    options;\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    _this = _super.call(this, pointerOptions) || this;\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n\n    _this.on;\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n\n    _this.once;\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n\n    _this.un;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.shouldHandle_ = false;\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n\n    _this.downPx_ = null;\n    /**\n     * @type {?}\n     * @private\n     */\n\n    _this.downTimeout_;\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n\n    _this.lastDragTime_;\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n\n    _this.pointerType_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.freehand_ = false;\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n\n    _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n\n    _this.type_ =\n    /** @type {import(\"../geom/Geometry.js\").Type} */\n    options.type;\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n\n    _this.mode_ = getMode(_this.type_);\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n\n    _this.stopClick_ = !!options.stopClick;\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n\n    _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Mode.POLYGON ? 3 : 2;\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n\n    _this.maxPoints_ = _this.mode_ === Mode.CIRCLE ? 2 : options.maxPoints ? options.maxPoints : Infinity;\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n\n    _this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;\n    /**\n     * @private\n     * @type {import(\"../geom/GeometryLayout\").default}\n     */\n\n    _this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : GeometryLayout.XY;\n    var geometryFunction = options.geometryFunction;\n\n    if (!geometryFunction) {\n      var mode_1 = _this.mode_;\n\n      if (mode_1 === Mode.CIRCLE) {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          var circle = geometry ?\n          /** @type {Circle} */\n          geometry : new Circle([NaN, NaN]);\n          var center = fromUserCoordinate(coordinates[0], projection);\n          var squaredLength = squaredCoordinateDistance(center, fromUserCoordinate(coordinates[coordinates.length - 1], projection));\n          circle.setCenterAndRadius(center, Math.sqrt(squaredLength), this.geometryLayout_);\n          var userProjection = getUserProjection();\n\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n\n          return circle;\n        };\n      } else {\n        var Constructor_1;\n\n        if (mode_1 === Mode.POINT) {\n          Constructor_1 = Point;\n        } else if (mode_1 === Mode.LINE_STRING) {\n          Constructor_1 = LineString;\n        } else if (mode_1 === Mode.POLYGON) {\n          Constructor_1 = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n\n\n        geometryFunction = function (coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode_1 === Mode.POLYGON) {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])], this.geometryLayout_);\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor_1(coordinates, this.geometryLayout_);\n          }\n\n          return geometry;\n        };\n      }\n    }\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n\n\n    _this.geometryFunction_ = geometryFunction;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    _this.finishCoordinate_ = null;\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n\n    _this.sketchFeature_ = null;\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n\n    _this.sketchPoint_ = null;\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n\n    _this.sketchCoords_ = null;\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n\n    _this.sketchLine_ = null;\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n\n    _this.sketchLineCoords_ = null;\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n\n    _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n\n    _this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true\n    });\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n\n    _this.geometryName_ = options.geometryName;\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n\n    _this.condition_ = options.condition ? options.condition : noModifierKeys;\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n\n    _this.freehandCondition_;\n\n    if (options.freehand) {\n      _this.freehandCondition_ = always;\n    } else {\n      _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;\n    }\n\n    _this.addChangeListener(InteractionProperty.ACTIVE, _this.updateState_);\n\n    return _this;\n  }\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n\n\n  Draw.prototype.setMap = function (map) {\n    _super.prototype.setMap.call(this, map);\n\n    this.updateState_();\n  };\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n\n\n  Draw.prototype.getOverlay = function () {\n    return this.overlay_;\n  };\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n\n\n  Draw.prototype.handleEvent = function (event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n\n    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n    var move = event.type === MapBrowserEventType.POINTERMOVE;\n    var pass = true;\n\n    if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {\n      var now = Date.now();\n\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n\n    if (this.freehand_ && event.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (this.freehand_ && event.type === MapBrowserEventType.POINTERDOWN) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (event.originalEvent.pointerType === 'mouse' || event.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === undefined) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return _super.prototype.handleEvent.call(this, event) && pass;\n  };\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  Draw.prototype.handleDownEvent = function (event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n\n      return true;\n    } else if (this.condition_(event)) {\n      this.lastDragTime_ = Date.now();\n      this.downTimeout_ = setTimeout(function () {\n        this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));\n      }.bind(this), this.dragVertexDelay_);\n      this.downPx_ = event.pixel;\n      return true;\n    } else {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  Draw.prototype.handleUpEvent = function (event) {\n    var pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n\n      if (this.shouldHandle_) {\n        var startingToDraw = !this.finishCoordinate_;\n\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (!this.freehand_ && (!startingToDraw || this.mode_ === Mode.POINT)) {\n          if (this.atFinish_(event.pixel)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n\n    return pass;\n  };\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n\n\n  Draw.prototype.handlePointerMove_ = function (event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n\n    if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {\n      var downPx = this.downPx_;\n      var clickPx = event.pixel;\n      var dx = downPx[0] - clickPx[0];\n      var dy = downPx[1] - clickPx[1];\n      var squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;\n\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (this.finishCoordinate_) {\n      this.modifyDrawing_(event.coordinate);\n    } else {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n    }\n  };\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n\n\n  Draw.prototype.atFinish_ = function (pixel) {\n    var at = false;\n\n    if (this.sketchFeature_) {\n      var potentiallyDone = false;\n      var potentiallyFinishCoordinates = [this.finishCoordinate_];\n      var mode = this.mode_;\n\n      if (mode === Mode.POINT) {\n        at = true;\n      } else if (mode === Mode.CIRCLE) {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === Mode.LINE_STRING) {\n        potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === Mode.POLYGON) {\n        var sketchCoords =\n        /** @type {PolyCoordType} */\n        this.sketchCoords_;\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];\n      }\n\n      if (potentiallyDone) {\n        var map = this.getMap();\n\n        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          var finishCoordinate = potentiallyFinishCoordinates[i];\n          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          var dx = pixel[0] - finishPixel[0];\n          var dy = pixel[1] - finishPixel[1];\n          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n\n    return at;\n  };\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n\n\n  Draw.prototype.createOrUpdateSketchPoint_ = function (coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      var sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  };\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n\n\n  Draw.prototype.createOrUpdateCustomSketchLine_ = function (geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n\n    var ring = geometry.getLinearRing(0);\n    var sketchLineGeom = this.sketchLine_.getGeometry();\n\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n      sketchLineGeom.changed();\n    }\n  };\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n\n\n  Draw.prototype.startDrawing_ = function (start) {\n    var projection = this.getMap().getView().getProjection();\n    var stride = getStrideForLayout(this.geometryLayout_);\n\n    while (start.length < stride) {\n      start.push(0);\n    }\n\n    this.finishCoordinate_ = start;\n\n    if (this.mode_ === Mode.POINT) {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === Mode.POLYGON) {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n\n    var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);\n    this.sketchFeature_ = new Feature();\n\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n\n\n  Draw.prototype.modifyDrawing_ = function (coordinate) {\n    var map = this.getMap();\n    var geometry = this.sketchFeature_.getGeometry();\n    var projection = map.getView().getProjection();\n    var stride = getStrideForLayout(this.geometryLayout_);\n    var coordinates, last;\n\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n\n    if (this.mode_ === Mode.POINT) {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates =\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0];\n      last = coordinates[coordinates.length - 1];\n\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n    /** @type {!LineCoordType} */\n    this.sketchCoords_, geometry, projection);\n\n    if (this.sketchPoint_) {\n      var sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n\n    if (geometry.getType() === 'Polygon' && this.mode_ !== Mode.POLYGON) {\n      this.createOrUpdateCustomSketchLine_(\n      /** @type {Polygon} */\n      geometry);\n    } else if (this.sketchLineCoords_) {\n      var sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n\n    this.updateSketchFeatures_();\n  };\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @private\n   */\n\n\n  Draw.prototype.addToDrawing_ = function (coordinate) {\n    var geometry = this.sketchFeature_.getGeometry();\n    var projection = this.getMap().getView().getProjection();\n    var done;\n    var coordinates;\n    var mode = this.mode_;\n\n    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates =\n      /** @type {LineCoordType} */\n      this.sketchCoords_;\n\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === Mode.POLYGON) {\n      coordinates =\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0];\n\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n\n      coordinates.push(coordinate.slice());\n\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n\n    if (done) {\n      this.finishDrawing();\n    }\n  };\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n\n\n  Draw.prototype.removeLastPoint = function () {\n    if (!this.sketchFeature_) {\n      return;\n    }\n\n    var geometry = this.sketchFeature_.getGeometry();\n    var projection = this.getMap().getView().getProjection();\n    var coordinates;\n    var mode = this.mode_;\n\n    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n      coordinates =\n      /** @type {LineCoordType} */\n      this.sketchCoords_;\n      coordinates.splice(-2, 1);\n\n      if (coordinates.length >= 2) {\n        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n        var finishCoordinate = this.finishCoordinate_.slice();\n        coordinates[coordinates.length - 1] = finishCoordinate;\n        this.createOrUpdateSketchPoint_(finishCoordinate);\n      }\n\n      this.geometryFunction_(coordinates, geometry, projection);\n\n      if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n        this.createOrUpdateCustomSketchLine_(\n        /** @type {Polygon} */\n        geometry);\n      }\n    } else if (mode === Mode.POLYGON) {\n      coordinates =\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0];\n      coordinates.splice(-2, 1);\n      var sketchLineGeom = this.sketchLine_.getGeometry();\n\n      if (coordinates.length >= 2) {\n        var finishCoordinate = coordinates[coordinates.length - 2].slice();\n        coordinates[coordinates.length - 1] = finishCoordinate;\n        this.createOrUpdateSketchPoint_(finishCoordinate);\n      }\n\n      sketchLineGeom.setCoordinates(coordinates);\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n\n    if (coordinates.length === 1) {\n      this.abortDrawing();\n    }\n\n    this.updateSketchFeatures_();\n  };\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @api\n   */\n\n\n  Draw.prototype.finishDrawing = function () {\n    var sketchFeature = this.abortDrawing_();\n\n    if (!sketchFeature) {\n      return;\n    }\n\n    var coordinates = this.sketchCoords_;\n    var geometry = sketchFeature.getGeometry();\n    var projection = this.getMap().getView().getProjection();\n\n    if (this.mode_ === Mode.LINE_STRING) {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === Mode.POLYGON) {\n      // remove the redundant last point in ring\n\n      /** @type {PolyCoordType} */\n      coordinates[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    } // cast multi-part geometries\n\n\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(new MultiPoint([\n      /** @type {PointCoordType} */\n      coordinates]));\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(new MultiLineString([\n      /** @type {LineCoordType} */\n      coordinates]));\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(new MultiPolygon([\n      /** @type {PolyCoordType} */\n      coordinates]));\n    } // First dispatch event to allow full set up of feature\n\n\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature)); // Then insert feature\n\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  };\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n\n\n  Draw.prototype.abortDrawing_ = function () {\n    this.finishCoordinate_ = null;\n    var sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    return sketchFeature;\n  };\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n\n\n  Draw.prototype.abortDrawing = function () {\n    var sketchFeature = this.abortDrawing_();\n\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  };\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n\n\n  Draw.prototype.appendCoordinates = function (coordinates) {\n    var mode = this.mode_;\n    var newDrawing = !this.sketchFeature_;\n\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n\n\n    var sketchCoords;\n\n    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n      sketchCoords =\n      /** @type {LineCoordType} */\n      this.sketchCoords_;\n    } else if (mode === Mode.POLYGON) {\n      sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ?\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0] : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    } // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n\n\n    sketchCoords.pop(); // Append coordinate list\n\n    for (var i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    var ending = coordinates[coordinates.length - 1]; // Duplicate last coordinate for sketch drawing (cursor position)\n\n    this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  };\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n\n\n  Draw.prototype.extend = function (feature) {\n    var geometry = feature.getGeometry();\n    var lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n\n\n  Draw.prototype.updateSketchFeatures_ = function () {\n    var sketchFeatures = [];\n\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n\n    var overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  };\n  /**\n   * @private\n   */\n\n\n  Draw.prototype.updateState_ = function () {\n    var map = this.getMap();\n    var active = this.getActive();\n\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n\n    this.overlay_.setMap(active ? map : null);\n  };\n\n  return Draw;\n}(PointerInteraction);\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\n\n\nfunction getDefaultStyleFunction() {\n  var styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [opt_sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [opt_angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\n\n\nexport function createRegularPolygon(opt_sides, opt_angle) {\n  return function (coordinates, opt_geometry, projection) {\n    var center = fromUserCoordinate(\n    /** @type {LineCoordType} */\n    coordinates[0], projection);\n    var end = fromUserCoordinate(\n    /** @type {LineCoordType} */\n    coordinates[coordinates.length - 1], projection);\n    var radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    var geometry = opt_geometry ?\n    /** @type {Polygon} */\n    opt_geometry : fromCircle(new Circle(center), opt_sides);\n    var angle = opt_angle;\n\n    if (!opt_angle && opt_angle !== 0) {\n      var x = end[0] - center[0];\n      var y = end[1] - center[1];\n      angle = Math.atan2(y, x);\n    }\n\n    makeRegular(geometry, center, radius, angle);\n    var userProjection = getUserProjection();\n\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n\n    return geometry;\n  };\n}\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\n\nexport function createBox() {\n  return function (coordinates, opt_geometry, projection) {\n    var extent = boundingExtent(\n    /** @type {LineCoordType} */\n    [coordinates[0], coordinates[coordinates.length - 1]].map(function (coordinate) {\n      return fromUserCoordinate(coordinate, projection);\n    }));\n    var boxCoordinates = [[getBottomLeft(extent), getBottomRight(extent), getTopRight(extent), getTopLeft(extent), getBottomLeft(extent)]];\n    var geometry = opt_geometry;\n\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n\n    var userProjection = getUserProjection();\n\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n\n    return geometry;\n  };\n}\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\n\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return Mode.POINT;\n\n    case 'LineString':\n    case 'MultiLineString':\n      return Mode.LINE_STRING;\n\n    case 'Polygon':\n    case 'MultiPolygon':\n      return Mode.POLYGON;\n\n    case 'Circle':\n      return Mode.CIRCLE;\n\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","Circle","Event","EventType","Feature","GeometryLayout","InteractionProperty","LineString","MapBrowserEvent","MapBrowserEventType","MultiLineString","MultiPoint","MultiPolygon","Point","PointerInteraction","Polygon","fromCircle","makeRegular","VectorLayer","VectorSource","FALSE","TRUE","always","noModifierKeys","shiftKeyOnly","boundingExtent","getBottomLeft","getBottomRight","getTopLeft","getTopRight","createEditingStyle","fromUserCoordinate","getUserProjection","getStrideForLayout","squaredDistance","squaredCoordinateDistance","Mode","POINT","LINE_STRING","POLYGON","CIRCLE","DrawEventType","DRAWSTART","DRAWEND","DRAWABORT","DrawEvent","_super","type","feature","_this","Draw","options","pointerOptions","stopDown","on","once","un","shouldHandle_","downPx_","downTimeout_","lastDragTime_","pointerType_","freehand_","source_","source","features_","features","snapTolerance_","snapTolerance","type_","mode_","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","Infinity","finishCondition_","finishCondition","geometryLayout_","geometryLayout","XY","geometryFunction","mode_1","coordinates","geometry","projection","circle","NaN","center","squaredLength","length","setCenterAndRadius","Math","sqrt","userProjection","transform","Constructor_1","setCoordinates","concat","geometryFunction_","dragVertexDelay_","dragVertexDelay","undefined","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","squaredClickTolerance_","clickTolerance","overlay_","useSpatialIndex","wrapX","style","getDefaultStyleFunction","updateWhileInteracting","geometryName_","geometryName","condition_","condition","freehandCondition_","freehand","freehandCondition","addChangeListener","ACTIVE","updateState_","setMap","map","getOverlay","handleEvent","event","originalEvent","CONTEXTMENU","preventDefault","move","POINTERMOVE","pass","POINTERDRAG","now","Date","pixel","clearTimeout","addToDrawing_","coordinate","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","handleDownEvent","startDrawing_","setTimeout","frameState","bind","handleUpEvent","startingToDraw","finishDrawing","atFinish_","abortDrawing","downPx","clickPx","dx","dy","modifyDrawing_","createOrUpdateSketchPoint_","slice","at","potentiallyDone","potentiallyFinishCoordinates","mode","sketchCoords","getMap","i","ii","finishCoordinate","finishPixel","getPixelFromCoordinate","updateSketchFeatures_","sketchPointGeom","getGeometry","createOrUpdateCustomSketchLine_","ring","getLinearRing","sketchLineGeom","getFlatCoordinates","getLayout","setGeometry","setFlatCoordinates","changed","start","getView","getProjection","stride","push","setGeometryName","dispatchEvent","last","getType","done","pop","removeLastPoint","splice","sketchFeature","abortDrawing_","getCoordinates","addFeature","getSource","clear","appendCoordinates","newDrawing","shift","ending","extend","lineString","sketchFeatures","overlaySource","addFeatures","active","getActive","styles","resolution","createRegularPolygon","opt_sides","opt_angle","opt_geometry","end","radius","angle","x","y","atan2","createBox","extent","boxCoordinates","Error"],"sources":["/home/asura/github/smartcity/node_modules/ol/interaction/Draw.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, { fromCircle, makeRegular } from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { always, noModifierKeys, shiftKeyOnly } from '../events/condition.js';\nimport { boundingExtent, getBottomLeft, getBottomRight, getTopLeft, getTopRight, } from '../extent.js';\nimport { createEditingStyle } from '../style/Style.js';\nimport { fromUserCoordinate, getUserProjection } from '../proj.js';\nimport { getStrideForLayout } from '../geom/SimpleGeometry.js';\nimport { squaredDistance as squaredCoordinateDistance } from '../coordinate.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n */\nvar Mode = {\n    POINT: 'Point',\n    LINE_STRING: 'LineString',\n    POLYGON: 'Polygon',\n    CIRCLE: 'Circle',\n};\n/**\n * @enum {string}\n */\nvar DrawEventType = {\n    /**\n     * Triggered upon feature draw start\n     * @event DrawEvent#drawstart\n     * @api\n     */\n    DRAWSTART: 'drawstart',\n    /**\n     * Triggered upon feature draw end\n     * @event DrawEvent#drawend\n     * @api\n     */\n    DRAWEND: 'drawend',\n    /**\n     * Triggered upon feature draw abortion\n     * @event DrawEvent#drawabort\n     * @api\n     */\n    DRAWABORT: 'drawabort',\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nvar DrawEvent = /** @class */ (function (_super) {\n    __extends(DrawEvent, _super);\n    /**\n     * @param {DrawEventType} type Type.\n     * @param {Feature} feature The feature drawn.\n     */\n    function DrawEvent(type, feature) {\n        var _this = _super.call(this, type) || this;\n        /**\n         * The feature being drawn.\n         * @type {Feature}\n         * @api\n         */\n        _this.feature = feature;\n        return _this;\n    }\n    return DrawEvent;\n}(Event));\nexport { DrawEvent };\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nvar Draw = /** @class */ (function (_super) {\n    __extends(Draw, _super);\n    /**\n     * @param {Options} options Options.\n     */\n    function Draw(options) {\n        var _this = this;\n        var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n        if (!pointerOptions.stopDown) {\n            pointerOptions.stopDown = FALSE;\n        }\n        _this = _super.call(this, pointerOptions) || this;\n        /***\n         * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.on;\n        /***\n         * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.once;\n        /***\n         * @type {DrawOnSignature<void>}\n         */\n        _this.un;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.shouldHandle_ = false;\n        /**\n         * @type {import(\"../pixel.js\").Pixel}\n         * @private\n         */\n        _this.downPx_ = null;\n        /**\n         * @type {?}\n         * @private\n         */\n        _this.downTimeout_;\n        /**\n         * @type {number|undefined}\n         * @private\n         */\n        _this.lastDragTime_;\n        /**\n         * Pointer type of the last pointermove event\n         * @type {string}\n         * @private\n         */\n        _this.pointerType_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.freehand_ = false;\n        /**\n         * Target source for drawn features.\n         * @type {VectorSource|null}\n         * @private\n         */\n        _this.source_ = options.source ? options.source : null;\n        /**\n         * Target collection for drawn features.\n         * @type {import(\"../Collection.js\").default<Feature>|null}\n         * @private\n         */\n        _this.features_ = options.features ? options.features : null;\n        /**\n         * Pixel distance for snapping.\n         * @type {number}\n         * @private\n         */\n        _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n        /**\n         * Geometry type.\n         * @type {import(\"../geom/Geometry.js\").Type}\n         * @private\n         */\n        _this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (options.type);\n        /**\n         * Drawing mode (derived from geometry type.\n         * @type {Mode}\n         * @private\n         */\n        _this.mode_ = getMode(_this.type_);\n        /**\n         * Stop click, singleclick, and doubleclick events from firing during drawing.\n         * Default is `false`.\n         * @type {boolean}\n         * @private\n         */\n        _this.stopClick_ = !!options.stopClick;\n        /**\n         * The number of points that must be drawn before a polygon ring or line\n         * string can be finished.  The default is 3 for polygon rings and 2 for\n         * line strings.\n         * @type {number}\n         * @private\n         */\n        _this.minPoints_ = options.minPoints\n            ? options.minPoints\n            : _this.mode_ === Mode.POLYGON\n                ? 3\n                : 2;\n        /**\n         * The number of points that can be drawn before a polygon ring or line string\n         * is finished. The default is no restriction.\n         * @type {number}\n         * @private\n         */\n        _this.maxPoints_ =\n            _this.mode_ === Mode.CIRCLE\n                ? 2\n                : options.maxPoints\n                    ? options.maxPoints\n                    : Infinity;\n        /**\n         * A function to decide if a potential finish coordinate is permissible\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.finishCondition_ = options.finishCondition\n            ? options.finishCondition\n            : TRUE;\n        /**\n         * @private\n         * @type {import(\"../geom/GeometryLayout\").default}\n         */\n        _this.geometryLayout_ = options.geometryLayout\n            ? options.geometryLayout\n            : GeometryLayout.XY;\n        var geometryFunction = options.geometryFunction;\n        if (!geometryFunction) {\n            var mode_1 = _this.mode_;\n            if (mode_1 === Mode.CIRCLE) {\n                /**\n                 * @param {!LineCoordType} coordinates The coordinates.\n                 * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n                 * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n                 * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n                 */\n                geometryFunction = function (coordinates, geometry, projection) {\n                    var circle = geometry\n                        ? /** @type {Circle} */ (geometry)\n                        : new Circle([NaN, NaN]);\n                    var center = fromUserCoordinate(coordinates[0], projection);\n                    var squaredLength = squaredCoordinateDistance(center, fromUserCoordinate(coordinates[coordinates.length - 1], projection));\n                    circle.setCenterAndRadius(center, Math.sqrt(squaredLength), this.geometryLayout_);\n                    var userProjection = getUserProjection();\n                    if (userProjection) {\n                        circle.transform(projection, userProjection);\n                    }\n                    return circle;\n                };\n            }\n            else {\n                var Constructor_1;\n                if (mode_1 === Mode.POINT) {\n                    Constructor_1 = Point;\n                }\n                else if (mode_1 === Mode.LINE_STRING) {\n                    Constructor_1 = LineString;\n                }\n                else if (mode_1 === Mode.POLYGON) {\n                    Constructor_1 = Polygon;\n                }\n                /**\n                 * @param {!LineCoordType} coordinates The coordinates.\n                 * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n                 * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n                 * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n                 */\n                geometryFunction = function (coordinates, geometry, projection) {\n                    if (geometry) {\n                        if (mode_1 === Mode.POLYGON) {\n                            if (coordinates[0].length) {\n                                // Add a closing coordinate to match the first\n                                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])], this.geometryLayout_);\n                            }\n                            else {\n                                geometry.setCoordinates([], this.geometryLayout_);\n                            }\n                        }\n                        else {\n                            geometry.setCoordinates(coordinates, this.geometryLayout_);\n                        }\n                    }\n                    else {\n                        geometry = new Constructor_1(coordinates, this.geometryLayout_);\n                    }\n                    return geometry;\n                };\n            }\n        }\n        /**\n         * @type {GeometryFunction}\n         * @private\n         */\n        _this.geometryFunction_ = geometryFunction;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.dragVertexDelay_ =\n            options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n        /**\n         * Finish coordinate for the feature (first point for polygons, last point for\n         * linestrings).\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.finishCoordinate_ = null;\n        /**\n         * Sketch feature.\n         * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n         * @private\n         */\n        _this.sketchFeature_ = null;\n        /**\n         * Sketch point.\n         * @type {Feature<Point>}\n         * @private\n         */\n        _this.sketchPoint_ = null;\n        /**\n         * Sketch coordinates. Used when drawing a line or polygon.\n         * @type {SketchCoordType}\n         * @private\n         */\n        _this.sketchCoords_ = null;\n        /**\n         * Sketch line. Used when drawing polygon.\n         * @type {Feature<LineString>}\n         * @private\n         */\n        _this.sketchLine_ = null;\n        /**\n         * Sketch line coordinates. Used when drawing a polygon or circle.\n         * @type {LineCoordType}\n         * @private\n         */\n        _this.sketchLineCoords_ = null;\n        /**\n         * Squared tolerance for handling up events.  If the squared distance\n         * between a down and up event is greater than this tolerance, up events\n         * will not be handled.\n         * @type {number}\n         * @private\n         */\n        _this.squaredClickTolerance_ = options.clickTolerance\n            ? options.clickTolerance * options.clickTolerance\n            : 36;\n        /**\n         * Draw overlay where our sketch features are drawn.\n         * @type {VectorLayer}\n         * @private\n         */\n        _this.overlay_ = new VectorLayer({\n            source: new VectorSource({\n                useSpatialIndex: false,\n                wrapX: options.wrapX ? options.wrapX : false,\n            }),\n            style: options.style ? options.style : getDefaultStyleFunction(),\n            updateWhileInteracting: true,\n        });\n        /**\n         * Name of the geometry attribute for newly created features.\n         * @type {string|undefined}\n         * @private\n         */\n        _this.geometryName_ = options.geometryName;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.condition_ = options.condition ? options.condition : noModifierKeys;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.freehandCondition_;\n        if (options.freehand) {\n            _this.freehandCondition_ = always;\n        }\n        else {\n            _this.freehandCondition_ = options.freehandCondition\n                ? options.freehandCondition\n                : shiftKeyOnly;\n        }\n        _this.addChangeListener(InteractionProperty.ACTIVE, _this.updateState_);\n        return _this;\n    }\n    /**\n     * Remove the interaction from its current map and attach it to the new map.\n     * Subclasses may set up event handlers to get notified about changes to\n     * the map here.\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     */\n    Draw.prototype.setMap = function (map) {\n        _super.prototype.setMap.call(this, map);\n        this.updateState_();\n    };\n    /**\n     * Get the overlay layer that this interaction renders sketch features to.\n     * @return {VectorLayer} Overlay layer.\n     * @api\n     */\n    Draw.prototype.getOverlay = function () {\n        return this.overlay_;\n    };\n    /**\n     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @api\n     */\n    Draw.prototype.handleEvent = function (event) {\n        if (event.originalEvent.type === EventType.CONTEXTMENU) {\n            // Avoid context menu for long taps when drawing on mobile\n            event.originalEvent.preventDefault();\n        }\n        this.freehand_ =\n            this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n        var move = event.type === MapBrowserEventType.POINTERMOVE;\n        var pass = true;\n        if (!this.freehand_ &&\n            this.lastDragTime_ &&\n            event.type === MapBrowserEventType.POINTERDRAG) {\n            var now = Date.now();\n            if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n                this.downPx_ = event.pixel;\n                this.shouldHandle_ = !this.freehand_;\n                move = true;\n            }\n            else {\n                this.lastDragTime_ = undefined;\n            }\n            if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n                clearTimeout(this.downTimeout_);\n                this.downTimeout_ = undefined;\n            }\n        }\n        if (this.freehand_ &&\n            event.type === MapBrowserEventType.POINTERDRAG &&\n            this.sketchFeature_ !== null) {\n            this.addToDrawing_(event.coordinate);\n            pass = false;\n        }\n        else if (this.freehand_ &&\n            event.type === MapBrowserEventType.POINTERDOWN) {\n            pass = false;\n        }\n        else if (move && this.getPointerCount() < 2) {\n            pass = event.type === MapBrowserEventType.POINTERMOVE;\n            if (pass && this.freehand_) {\n                this.handlePointerMove_(event);\n                if (this.shouldHandle_) {\n                    // Avoid page scrolling when freehand drawing on mobile\n                    event.originalEvent.preventDefault();\n                }\n            }\n            else if (event.originalEvent.pointerType === 'mouse' ||\n                (event.type === MapBrowserEventType.POINTERDRAG &&\n                    this.downTimeout_ === undefined)) {\n                this.handlePointerMove_(event);\n            }\n        }\n        else if (event.type === MapBrowserEventType.DBLCLICK) {\n            pass = false;\n        }\n        return _super.prototype.handleEvent.call(this, event) && pass;\n    };\n    /**\n     * Handle pointer down events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Draw.prototype.handleDownEvent = function (event) {\n        this.shouldHandle_ = !this.freehand_;\n        if (this.freehand_) {\n            this.downPx_ = event.pixel;\n            if (!this.finishCoordinate_) {\n                this.startDrawing_(event.coordinate);\n            }\n            return true;\n        }\n        else if (this.condition_(event)) {\n            this.lastDragTime_ = Date.now();\n            this.downTimeout_ = setTimeout(function () {\n                this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));\n            }.bind(this), this.dragVertexDelay_);\n            this.downPx_ = event.pixel;\n            return true;\n        }\n        else {\n            this.lastDragTime_ = undefined;\n            return false;\n        }\n    };\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Draw.prototype.handleUpEvent = function (event) {\n        var pass = true;\n        if (this.getPointerCount() === 0) {\n            if (this.downTimeout_) {\n                clearTimeout(this.downTimeout_);\n                this.downTimeout_ = undefined;\n            }\n            this.handlePointerMove_(event);\n            if (this.shouldHandle_) {\n                var startingToDraw = !this.finishCoordinate_;\n                if (startingToDraw) {\n                    this.startDrawing_(event.coordinate);\n                }\n                if (!startingToDraw && this.freehand_) {\n                    this.finishDrawing();\n                }\n                else if (!this.freehand_ &&\n                    (!startingToDraw || this.mode_ === Mode.POINT)) {\n                    if (this.atFinish_(event.pixel)) {\n                        if (this.finishCondition_(event)) {\n                            this.finishDrawing();\n                        }\n                    }\n                    else {\n                        this.addToDrawing_(event.coordinate);\n                    }\n                }\n                pass = false;\n            }\n            else if (this.freehand_) {\n                this.abortDrawing();\n            }\n        }\n        if (!pass && this.stopClick_) {\n            event.preventDefault();\n        }\n        return pass;\n    };\n    /**\n     * Handle move events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n     * @private\n     */\n    Draw.prototype.handlePointerMove_ = function (event) {\n        this.pointerType_ = event.originalEvent.pointerType;\n        if (this.downPx_ &&\n            ((!this.freehand_ && this.shouldHandle_) ||\n                (this.freehand_ && !this.shouldHandle_))) {\n            var downPx = this.downPx_;\n            var clickPx = event.pixel;\n            var dx = downPx[0] - clickPx[0];\n            var dy = downPx[1] - clickPx[1];\n            var squaredDistance = dx * dx + dy * dy;\n            this.shouldHandle_ = this.freehand_\n                ? squaredDistance > this.squaredClickTolerance_\n                : squaredDistance <= this.squaredClickTolerance_;\n            if (!this.shouldHandle_) {\n                return;\n            }\n        }\n        if (this.finishCoordinate_) {\n            this.modifyDrawing_(event.coordinate);\n        }\n        else {\n            this.createOrUpdateSketchPoint_(event.coordinate.slice());\n        }\n    };\n    /**\n     * Determine if an event is within the snapping tolerance of the start coord.\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n     * @return {boolean} The event is within the snapping tolerance of the start.\n     * @private\n     */\n    Draw.prototype.atFinish_ = function (pixel) {\n        var at = false;\n        if (this.sketchFeature_) {\n            var potentiallyDone = false;\n            var potentiallyFinishCoordinates = [this.finishCoordinate_];\n            var mode = this.mode_;\n            if (mode === Mode.POINT) {\n                at = true;\n            }\n            else if (mode === Mode.CIRCLE) {\n                at = this.sketchCoords_.length === 2;\n            }\n            else if (mode === Mode.LINE_STRING) {\n                potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n            }\n            else if (mode === Mode.POLYGON) {\n                var sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n                potentiallyDone = sketchCoords[0].length > this.minPoints_;\n                potentiallyFinishCoordinates = [\n                    sketchCoords[0][0],\n                    sketchCoords[0][sketchCoords[0].length - 2],\n                ];\n            }\n            if (potentiallyDone) {\n                var map = this.getMap();\n                for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n                    var finishCoordinate = potentiallyFinishCoordinates[i];\n                    var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n                    var dx = pixel[0] - finishPixel[0];\n                    var dy = pixel[1] - finishPixel[1];\n                    var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n                    at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n                    if (at) {\n                        this.finishCoordinate_ = finishCoordinate;\n                        break;\n                    }\n                }\n            }\n        }\n        return at;\n    };\n    /**\n     * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n     * @private\n     */\n    Draw.prototype.createOrUpdateSketchPoint_ = function (coordinates) {\n        if (!this.sketchPoint_) {\n            this.sketchPoint_ = new Feature(new Point(coordinates));\n            this.updateSketchFeatures_();\n        }\n        else {\n            var sketchPointGeom = this.sketchPoint_.getGeometry();\n            sketchPointGeom.setCoordinates(coordinates);\n        }\n    };\n    /**\n     * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n     * @private\n     */\n    Draw.prototype.createOrUpdateCustomSketchLine_ = function (geometry) {\n        if (!this.sketchLine_) {\n            this.sketchLine_ = new Feature();\n        }\n        var ring = geometry.getLinearRing(0);\n        var sketchLineGeom = this.sketchLine_.getGeometry();\n        if (!sketchLineGeom) {\n            sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());\n            this.sketchLine_.setGeometry(sketchLineGeom);\n        }\n        else {\n            sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n            sketchLineGeom.changed();\n        }\n    };\n    /**\n     * Start the drawing.\n     * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n     * @private\n     */\n    Draw.prototype.startDrawing_ = function (start) {\n        var projection = this.getMap().getView().getProjection();\n        var stride = getStrideForLayout(this.geometryLayout_);\n        while (start.length < stride) {\n            start.push(0);\n        }\n        this.finishCoordinate_ = start;\n        if (this.mode_ === Mode.POINT) {\n            this.sketchCoords_ = start.slice();\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            this.sketchCoords_ = [[start.slice(), start.slice()]];\n            this.sketchLineCoords_ = this.sketchCoords_[0];\n        }\n        else {\n            this.sketchCoords_ = [start.slice(), start.slice()];\n        }\n        if (this.sketchLineCoords_) {\n            this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n        }\n        var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);\n        this.sketchFeature_ = new Feature();\n        if (this.geometryName_) {\n            this.sketchFeature_.setGeometryName(this.geometryName_);\n        }\n        this.sketchFeature_.setGeometry(geometry);\n        this.updateSketchFeatures_();\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n    };\n    /**\n     * Modify the drawing.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @private\n     */\n    Draw.prototype.modifyDrawing_ = function (coordinate) {\n        var map = this.getMap();\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = map.getView().getProjection();\n        var stride = getStrideForLayout(this.geometryLayout_);\n        var coordinates, last;\n        while (coordinate.length < stride) {\n            coordinate.push(0);\n        }\n        if (this.mode_ === Mode.POINT) {\n            last = this.sketchCoords_;\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            last = coordinates[coordinates.length - 1];\n            if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n                // snap to finish\n                coordinate = this.finishCoordinate_.slice();\n            }\n        }\n        else {\n            coordinates = this.sketchCoords_;\n            last = coordinates[coordinates.length - 1];\n        }\n        last[0] = coordinate[0];\n        last[1] = coordinate[1];\n        this.geometryFunction_(\n        /** @type {!LineCoordType} */ (this.sketchCoords_), geometry, projection);\n        if (this.sketchPoint_) {\n            var sketchPointGeom = this.sketchPoint_.getGeometry();\n            sketchPointGeom.setCoordinates(coordinate);\n        }\n        if (geometry.getType() === 'Polygon' && this.mode_ !== Mode.POLYGON) {\n            this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n        }\n        else if (this.sketchLineCoords_) {\n            var sketchLineGeom = this.sketchLine_.getGeometry();\n            sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n        }\n        this.updateSketchFeatures_();\n    };\n    /**\n     * Add a new coordinate to the drawing.\n     * @param {!PointCoordType} coordinate Coordinate\n     * @private\n     */\n    Draw.prototype.addToDrawing_ = function (coordinate) {\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        var done;\n        var coordinates;\n        var mode = this.mode_;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            this.finishCoordinate_ = coordinate.slice();\n            coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n            if (coordinates.length >= this.maxPoints_) {\n                if (this.freehand_) {\n                    coordinates.pop();\n                }\n                else {\n                    done = true;\n                }\n            }\n            coordinates.push(coordinate.slice());\n            this.geometryFunction_(coordinates, geometry, projection);\n        }\n        else if (mode === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            if (coordinates.length >= this.maxPoints_) {\n                if (this.freehand_) {\n                    coordinates.pop();\n                }\n                else {\n                    done = true;\n                }\n            }\n            coordinates.push(coordinate.slice());\n            if (done) {\n                this.finishCoordinate_ = coordinates[0];\n            }\n            this.geometryFunction_(this.sketchCoords_, geometry, projection);\n        }\n        this.createOrUpdateSketchPoint_(coordinate.slice());\n        this.updateSketchFeatures_();\n        if (done) {\n            this.finishDrawing();\n        }\n    };\n    /**\n     * Remove last point of the feature currently being drawn. Does not do anything when\n     * drawing POINT or MULTI_POINT geometries.\n     * @api\n     */\n    Draw.prototype.removeLastPoint = function () {\n        if (!this.sketchFeature_) {\n            return;\n        }\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        var coordinates;\n        var mode = this.mode_;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n            coordinates.splice(-2, 1);\n            if (coordinates.length >= 2) {\n                this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n                var finishCoordinate = this.finishCoordinate_.slice();\n                coordinates[coordinates.length - 1] = finishCoordinate;\n                this.createOrUpdateSketchPoint_(finishCoordinate);\n            }\n            this.geometryFunction_(coordinates, geometry, projection);\n            if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n                this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n            }\n        }\n        else if (mode === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            coordinates.splice(-2, 1);\n            var sketchLineGeom = this.sketchLine_.getGeometry();\n            if (coordinates.length >= 2) {\n                var finishCoordinate = coordinates[coordinates.length - 2].slice();\n                coordinates[coordinates.length - 1] = finishCoordinate;\n                this.createOrUpdateSketchPoint_(finishCoordinate);\n            }\n            sketchLineGeom.setCoordinates(coordinates);\n            this.geometryFunction_(this.sketchCoords_, geometry, projection);\n        }\n        if (coordinates.length === 1) {\n            this.abortDrawing();\n        }\n        this.updateSketchFeatures_();\n    };\n    /**\n     * Stop drawing and add the sketch feature to the target layer.\n     * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n     * dispatched before inserting the feature.\n     * @api\n     */\n    Draw.prototype.finishDrawing = function () {\n        var sketchFeature = this.abortDrawing_();\n        if (!sketchFeature) {\n            return;\n        }\n        var coordinates = this.sketchCoords_;\n        var geometry = sketchFeature.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        if (this.mode_ === Mode.LINE_STRING) {\n            // remove the redundant last point\n            coordinates.pop();\n            this.geometryFunction_(coordinates, geometry, projection);\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            // remove the redundant last point in ring\n            /** @type {PolyCoordType} */ (coordinates)[0].pop();\n            this.geometryFunction_(coordinates, geometry, projection);\n            coordinates = geometry.getCoordinates();\n        }\n        // cast multi-part geometries\n        if (this.type_ === 'MultiPoint') {\n            sketchFeature.setGeometry(new MultiPoint([/** @type {PointCoordType} */ (coordinates)]));\n        }\n        else if (this.type_ === 'MultiLineString') {\n            sketchFeature.setGeometry(new MultiLineString([/** @type {LineCoordType} */ (coordinates)]));\n        }\n        else if (this.type_ === 'MultiPolygon') {\n            sketchFeature.setGeometry(new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]));\n        }\n        // First dispatch event to allow full set up of feature\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n        // Then insert feature\n        if (this.features_) {\n            this.features_.push(sketchFeature);\n        }\n        if (this.source_) {\n            this.source_.addFeature(sketchFeature);\n        }\n    };\n    /**\n     * Stop drawing without adding the sketch feature to the target layer.\n     * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n     * @private\n     */\n    Draw.prototype.abortDrawing_ = function () {\n        this.finishCoordinate_ = null;\n        var sketchFeature = this.sketchFeature_;\n        this.sketchFeature_ = null;\n        this.sketchPoint_ = null;\n        this.sketchLine_ = null;\n        this.overlay_.getSource().clear(true);\n        return sketchFeature;\n    };\n    /**\n     * Stop drawing without adding the sketch feature to the target layer.\n     * @api\n     */\n    Draw.prototype.abortDrawing = function () {\n        var sketchFeature = this.abortDrawing_();\n        if (sketchFeature) {\n            this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n        }\n    };\n    /**\n     * Append coordinates to the end of the geometry that is currently being drawn.\n     * This can be used when drawing LineStrings or Polygons. Coordinates will\n     * either be appended to the current LineString or the outer ring of the current\n     * Polygon. If no geometry is being drawn, a new one will be created.\n     * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n     * the coordinate array.\n     * @api\n     */\n    Draw.prototype.appendCoordinates = function (coordinates) {\n        var mode = this.mode_;\n        var newDrawing = !this.sketchFeature_;\n        if (newDrawing) {\n            this.startDrawing_(coordinates[0]);\n        }\n        /** @type {LineCoordType} */\n        var sketchCoords;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n        }\n        else if (mode === Mode.POLYGON) {\n            sketchCoords =\n                this.sketchCoords_ && this.sketchCoords_.length\n                    ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n                    : [];\n        }\n        else {\n            return;\n        }\n        if (newDrawing) {\n            sketchCoords.shift();\n        }\n        // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n        sketchCoords.pop();\n        // Append coordinate list\n        for (var i = 0; i < coordinates.length; i++) {\n            this.addToDrawing_(coordinates[i]);\n        }\n        var ending = coordinates[coordinates.length - 1];\n        // Duplicate last coordinate for sketch drawing (cursor position)\n        this.addToDrawing_(ending);\n        this.modifyDrawing_(ending);\n    };\n    /**\n     * Initiate draw mode by starting from an existing geometry which will\n     * receive new additional points. This only works on features with\n     * `LineString` geometries, where the interaction will extend lines by adding\n     * points to the end of the coordinates array.\n     * This will change the original feature, instead of drawing a copy.\n     *\n     * The function will dispatch a `drawstart` event.\n     *\n     * @param {!Feature<LineString>} feature Feature to be extended.\n     * @api\n     */\n    Draw.prototype.extend = function (feature) {\n        var geometry = feature.getGeometry();\n        var lineString = geometry;\n        this.sketchFeature_ = feature;\n        this.sketchCoords_ = lineString.getCoordinates();\n        var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n        this.finishCoordinate_ = last.slice();\n        this.sketchCoords_.push(last.slice());\n        this.sketchPoint_ = new Feature(new Point(last));\n        this.updateSketchFeatures_();\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n    };\n    /**\n     * Redraw the sketch features.\n     * @private\n     */\n    Draw.prototype.updateSketchFeatures_ = function () {\n        var sketchFeatures = [];\n        if (this.sketchFeature_) {\n            sketchFeatures.push(this.sketchFeature_);\n        }\n        if (this.sketchLine_) {\n            sketchFeatures.push(this.sketchLine_);\n        }\n        if (this.sketchPoint_) {\n            sketchFeatures.push(this.sketchPoint_);\n        }\n        var overlaySource = this.overlay_.getSource();\n        overlaySource.clear(true);\n        overlaySource.addFeatures(sketchFeatures);\n    };\n    /**\n     * @private\n     */\n    Draw.prototype.updateState_ = function () {\n        var map = this.getMap();\n        var active = this.getActive();\n        if (!map || !active) {\n            this.abortDrawing();\n        }\n        this.overlay_.setMap(active ? map : null);\n    };\n    return Draw;\n}(PointerInteraction));\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n    var styles = createEditingStyle();\n    return function (feature, resolution) {\n        return styles[feature.getGeometry().getType()];\n    };\n}\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [opt_sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [opt_angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(opt_sides, opt_angle) {\n    return function (coordinates, opt_geometry, projection) {\n        var center = fromUserCoordinate(\n        /** @type {LineCoordType} */ (coordinates)[0], projection);\n        var end = fromUserCoordinate(\n        /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1], projection);\n        var radius = Math.sqrt(squaredCoordinateDistance(center, end));\n        var geometry = opt_geometry\n            ? /** @type {Polygon} */ (opt_geometry)\n            : fromCircle(new Circle(center), opt_sides);\n        var angle = opt_angle;\n        if (!opt_angle && opt_angle !== 0) {\n            var x = end[0] - center[0];\n            var y = end[1] - center[1];\n            angle = Math.atan2(y, x);\n        }\n        makeRegular(geometry, center, radius, angle);\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            geometry.transform(projection, userProjection);\n        }\n        return geometry;\n    };\n}\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n    return function (coordinates, opt_geometry, projection) {\n        var extent = boundingExtent(\n        /** @type {LineCoordType} */ ([\n            coordinates[0],\n            coordinates[coordinates.length - 1],\n        ]).map(function (coordinate) {\n            return fromUserCoordinate(coordinate, projection);\n        }));\n        var boxCoordinates = [\n            [\n                getBottomLeft(extent),\n                getBottomRight(extent),\n                getTopRight(extent),\n                getTopLeft(extent),\n                getBottomLeft(extent),\n            ],\n        ];\n        var geometry = opt_geometry;\n        if (geometry) {\n            geometry.setCoordinates(boxCoordinates);\n        }\n        else {\n            geometry = new Polygon(boxCoordinates);\n        }\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            geometry.transform(projection, userProjection);\n        }\n        return geometry;\n    };\n}\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n    switch (type) {\n        case 'Point':\n        case 'MultiPoint':\n            return Mode.POINT;\n        case 'LineString':\n        case 'MultiLineString':\n            return Mode.LINE_STRING;\n        case 'Polygon':\n        case 'MultiPolygon':\n            return Mode.POLYGON;\n        case 'Circle':\n            return Mode.CIRCLE;\n        default:\n            throw new Error('Invalid type: ' + type);\n    }\n}\nexport default Draw;\n"],"mappings":"AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;EACrD,IAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;IAChCF,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;MAAEC,SAAS,EAAE;IAAb,aAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;MAAED,CAAC,CAACI,SAAF,GAAcH,CAAd;IAAkB,CAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;MAAE,KAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIC,MAAM,CAACK,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCR,CAArC,EAAwCK,CAAxC,CAAJ,EAAgDN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;IAAc,CAFrG;;IAGA,OAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;EACH,CALD;;EAMA,OAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;IACnB,IAAI,OAAOA,CAAP,KAAa,UAAb,IAA2BA,CAAC,KAAK,IAArC,EACI,MAAM,IAAIS,SAAJ,CAAc,yBAAyBC,MAAM,CAACV,CAAD,CAA/B,GAAqC,+BAAnD,CAAN;IACJF,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;IACA,SAASW,EAAT,GAAc;MAAE,KAAKC,WAAL,GAAmBb,CAAnB;IAAuB;;IACvCA,CAAC,CAACO,SAAF,GAAcN,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACY,MAAP,CAAcb,CAAd,CAAb,IAAiCW,EAAE,CAACL,SAAH,GAAeN,CAAC,CAACM,SAAjB,EAA4B,IAAIK,EAAJ,EAA7D,CAAd;EACH,CAND;AAOH,CAd2C,EAA5C;AAeA;AACA;AACA;;;AACA,OAAOG,MAAP,MAAmB,mBAAnB;AACA,OAAOC,KAAP,MAAkB,oBAAlB;AACA,OAAOC,SAAP,MAAsB,wBAAtB;AACA,OAAOC,OAAP,MAAoB,eAApB;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,mBAAP,MAAgC,eAAhC;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,eAAP,MAA4B,uBAA5B;AACA,OAAOC,mBAAP,MAAgC,2BAAhC;AACA,OAAOC,eAAP,MAA4B,4BAA5B;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,kBAAP,MAA+B,cAA/B;AACA,OAAOC,OAAP,IAAkBC,UAAlB,EAA8BC,WAA9B,QAAiD,oBAAjD;AACA,OAAOC,WAAP,MAAwB,oBAAxB;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AACA,SAASC,KAAT,EAAgBC,IAAhB,QAA4B,iBAA5B;AACA,SAASC,MAAT,EAAiBC,cAAjB,EAAiCC,YAAjC,QAAqD,wBAArD;AACA,SAASC,cAAT,EAAyBC,aAAzB,EAAwCC,cAAxC,EAAwDC,UAAxD,EAAoEC,WAApE,QAAwF,cAAxF;AACA,SAASC,kBAAT,QAAmC,mBAAnC;AACA,SAASC,kBAAT,EAA6BC,iBAA7B,QAAsD,YAAtD;AACA,SAASC,kBAAT,QAAmC,2BAAnC;AACA,SAASC,eAAe,IAAIC,yBAA5B,QAA6D,kBAA7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,IAAI,GAAG;EACPC,KAAK,EAAE,OADA;EAEPC,WAAW,EAAE,YAFN;EAGPC,OAAO,EAAE,SAHF;EAIPC,MAAM,EAAE;AAJD,CAAX;AAMA;AACA;AACA;;AACA,IAAIC,aAAa,GAAG;EAChB;AACJ;AACA;AACA;AACA;EACIC,SAAS,EAAE,WANK;;EAOhB;AACJ;AACA;AACA;AACA;EACIC,OAAO,EAAE,SAZO;;EAahB;AACJ;AACA;AACA;AACA;EACIC,SAAS,EAAE;AAlBK,CAApB;AAoBA;AACA;AACA;AACA;AACA;;AACA,IAAIC,SAAS;AAAG;AAAe,UAAUC,MAAV,EAAkB;EAC7C9D,SAAS,CAAC6D,SAAD,EAAYC,MAAZ,CAAT;EACA;AACJ;AACA;AACA;;;EACI,SAASD,SAAT,CAAmBE,IAAnB,EAAyBC,OAAzB,EAAkC;IAC9B,IAAIC,KAAK,GAAGH,MAAM,CAACnD,IAAP,CAAY,IAAZ,EAAkBoD,IAAlB,KAA2B,IAAvC;IACA;AACR;AACA;AACA;AACA;;;IACQE,KAAK,CAACD,OAAN,GAAgBA,OAAhB;IACA,OAAOC,KAAP;EACH;;EACD,OAAOJ,SAAP;AACH,CAjB8B,CAiB7B3C,KAjB6B,CAA/B;;AAkBA,SAAS2C,SAAT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIK,IAAI;AAAG;AAAe,UAAUJ,MAAV,EAAkB;EACxC9D,SAAS,CAACkE,IAAD,EAAOJ,MAAP,CAAT;EACA;AACJ;AACA;;;EACI,SAASI,IAAT,CAAcC,OAAd,EAAuB;IACnB,IAAIF,KAAK,GAAG,IAAZ;;IACA,IAAIG,cAAc;IAAG;IAA+CD,OAApE;;IACA,IAAI,CAACC,cAAc,CAACC,QAApB,EAA8B;MAC1BD,cAAc,CAACC,QAAf,GAA0BjC,KAA1B;IACH;;IACD6B,KAAK,GAAGH,MAAM,CAACnD,IAAP,CAAY,IAAZ,EAAkByD,cAAlB,KAAqC,IAA7C;IACA;AACR;AACA;;IACQH,KAAK,CAACK,EAAN;IACA;AACR;AACA;;IACQL,KAAK,CAACM,IAAN;IACA;AACR;AACA;;IACQN,KAAK,CAACO,EAAN;IACA;AACR;AACA;AACA;;IACQP,KAAK,CAACQ,aAAN,GAAsB,KAAtB;IACA;AACR;AACA;AACA;;IACQR,KAAK,CAACS,OAAN,GAAgB,IAAhB;IACA;AACR;AACA;AACA;;IACQT,KAAK,CAACU,YAAN;IACA;AACR;AACA;AACA;;IACQV,KAAK,CAACW,aAAN;IACA;AACR;AACA;AACA;AACA;;IACQX,KAAK,CAACY,YAAN;IACA;AACR;AACA;AACA;;IACQZ,KAAK,CAACa,SAAN,GAAkB,KAAlB;IACA;AACR;AACA;AACA;AACA;;IACQb,KAAK,CAACc,OAAN,GAAgBZ,OAAO,CAACa,MAAR,GAAiBb,OAAO,CAACa,MAAzB,GAAkC,IAAlD;IACA;AACR;AACA;AACA;AACA;;IACQf,KAAK,CAACgB,SAAN,GAAkBd,OAAO,CAACe,QAAR,GAAmBf,OAAO,CAACe,QAA3B,GAAsC,IAAxD;IACA;AACR;AACA;AACA;AACA;;IACQjB,KAAK,CAACkB,cAAN,GAAuBhB,OAAO,CAACiB,aAAR,GAAwBjB,OAAO,CAACiB,aAAhC,GAAgD,EAAvE;IACA;AACR;AACA;AACA;AACA;;IACQnB,KAAK,CAACoB,KAAN;IAAc;IAAmDlB,OAAO,CAACJ,IAAzE;IACA;AACR;AACA;AACA;AACA;;IACQE,KAAK,CAACqB,KAAN,GAAcC,OAAO,CAACtB,KAAK,CAACoB,KAAP,CAArB;IACA;AACR;AACA;AACA;AACA;AACA;;IACQpB,KAAK,CAACuB,UAAN,GAAmB,CAAC,CAACrB,OAAO,CAACsB,SAA7B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQxB,KAAK,CAACyB,UAAN,GAAmBvB,OAAO,CAACwB,SAAR,GACbxB,OAAO,CAACwB,SADK,GAEb1B,KAAK,CAACqB,KAAN,KAAgBlC,IAAI,CAACG,OAArB,GACI,CADJ,GAEI,CAJV;IAKA;AACR;AACA;AACA;AACA;AACA;;IACQU,KAAK,CAAC2B,UAAN,GACI3B,KAAK,CAACqB,KAAN,KAAgBlC,IAAI,CAACI,MAArB,GACM,CADN,GAEMW,OAAO,CAAC0B,SAAR,GACI1B,OAAO,CAAC0B,SADZ,GAEIC,QALd;IAMA;AACR;AACA;AACA;AACA;;IACQ7B,KAAK,CAAC8B,gBAAN,GAAyB5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"},"metadata":{},"sourceType":"module"}