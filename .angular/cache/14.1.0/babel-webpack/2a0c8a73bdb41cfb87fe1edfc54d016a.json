{"ast":null,"code":"/**\n * @module ol/resolutionconstraint\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\n\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n  var xResolution = getWidth(maxExtent) / viewportSize[0];\n  var yResolution = getHeight(maxExtent) / viewportSize[1];\n\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\n\n\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  var result = Math.min(resolution, maxResolution);\n  var ratio = 50;\n  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;\n\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;\n  }\n\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\n\n\nexport function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var maxResolution = resolutions[0];\n        var minResolution = resolutions[resolutions.length - 1];\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values\n\n        if (opt_isMoving) {\n          var smooth = opt_smooth !== undefined ? opt_smooth : true;\n\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n\n        var capped = Math.min(cappedMaxRes, resolution);\n        var z = Math.floor(linearFindNearest(resolutions, capped, direction));\n\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n\n        return resolutions[z];\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [opt_minResolution] Minimum resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\n\nexport function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n        var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0; // during interacting or animating, allow intermediary values\n\n        if (opt_isMoving) {\n          var smooth = opt_smooth !== undefined ? opt_smooth : true;\n\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n\n        var tolerance = 1e-9;\n        var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n        var offset = -direction * (0.5 - tolerance) + 0.5;\n        var capped = Math.min(cappedMaxRes, resolution);\n        var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n        var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        var newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\n\nexport function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n        var smooth = opt_smooth !== undefined ? opt_smooth : true;\n\n        if (!smooth || !opt_isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n\n        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}","map":{"version":3,"names":["clamp","getHeight","getWidth","linearFindNearest","getViewportClampedResolution","resolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","Math","min","max","getSmoothClampedResolution","maxResolution","minResolution","result","ratio","log","createSnapToResolutions","resolutions","opt_smooth","opt_maxExtent","opt_showFullExtent","direction","size","opt_isMoving","undefined","length","cappedMaxRes","smooth","capped","z","floor","createSnapToPower","power","opt_minResolution","tolerance","minZoomLevel","ceil","offset","cappedZoomLevel","zoomLevel","newResolution","pow","createMinMaxResolution"],"sources":["/home/asura/github/smartcity/node_modules/ol/resolutionconstraint.js"],"sourcesContent":["/**\n * @module ol/resolutionconstraint\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n    var xResolution = getWidth(maxExtent) / viewportSize[0];\n    var yResolution = getHeight(maxExtent) / viewportSize[1];\n    if (showFullExtent) {\n        return Math.min(resolution, Math.max(xResolution, yResolution));\n    }\n    return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n    var result = Math.min(resolution, maxResolution);\n    var ratio = 50;\n    result *=\n        Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n            1;\n    if (minResolution) {\n        result = Math.max(result, minResolution);\n        result /=\n            Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n                ratio +\n                1;\n    }\n    return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var maxResolution = resolutions[0];\n            var minResolution = resolutions[resolutions.length - 1];\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var capped = Math.min(cappedMaxRes, resolution);\n            var z = Math.floor(linearFindNearest(resolutions, capped, direction));\n            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n                return resolutions[z + 1];\n            }\n            return resolutions[z];\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [opt_minResolution] Minimum resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var tolerance = 1e-9;\n            var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n            var offset = -direction * (0.5 - tolerance) + 0.5;\n            var capped = Math.min(cappedMaxRes, resolution);\n            var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n            var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n            var newResolution = maxResolution / Math.pow(power, zoomLevel);\n            return clamp(newResolution, minResolution, cappedMaxRes);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            var smooth = opt_smooth !== undefined ? opt_smooth : true;\n            if (!smooth || !opt_isMoving) {\n                return clamp(resolution, minResolution, cappedMaxRes);\n            }\n            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}