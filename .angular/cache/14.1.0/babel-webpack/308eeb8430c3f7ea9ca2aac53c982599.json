{"ast":null,"code":"/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../../has.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray } from '../../transform.js';\nimport { createEmpty, createOrUpdate, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextAlign, defaultTextBaseline, drawImageOrLabel, getTextDimensions, measureAndCacheTextWidth } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @typedef {Object} BBox\n * @property {number} minX Minimal x.\n * @property {number} minY Minimal y.\n * @property {number} maxX Maximal x.\n * @property {number} maxY Maximal y\n * @property {*} value Value.\n */\n\n/**\n * @typedef {Object} ImageOrLabelDimensions\n * @property {number} drawImageX DrawImageX.\n * @property {number} drawImageY DrawImageY.\n * @property {number} drawImageW DrawImageW.\n * @property {number} drawImageH DrawImageH.\n * @property {number} originX OriginX.\n * @property {number} originY OriginY.\n * @property {Array<number>} scale Scale.\n * @property {BBox} declutterBox DeclutterBox.\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\n */\n\n/**\n * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\n */\n\n/**\n * @template T\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\n\nvar tmpExtent = createEmpty();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p4 = [];\n/**\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\n * @return {BBox} Declutter bbox.\n */\n\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n  return replayImageOrLabelArgs[3].declutterBox;\n}\n\nvar rtlRegEx = new RegExp(\n/* eslint-disable prettier/prettier */\n'[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']'\n/* eslint-enable prettier/prettier */\n);\n/**\n * @param {string} text Text.\n * @param {string} align Alignment.\n * @return {number} Text alignment.\n */\n\nfunction horizontalTextAlign(text, align) {\n  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {\n    align = align === 'start' ? 'left' : 'right';\n  }\n\n  return TEXT_ALIGN[align];\n}\n/**\n * @param {Array<string>} acc Accumulator.\n * @param {string} line Line of text.\n * @param {number} i Index\n * @return {Array<string>} Accumulator.\n */\n\n\nfunction createTextChunks(acc, line, i) {\n  if (i > 0) {\n    acc.push('\\n', '');\n  }\n\n  acc.push(line, '');\n  return acc;\n}\n\nvar Executor =\n/** @class */\nfunction () {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions\n   */\n  function Executor(resolution, pixelRatio, overlaps, instructions) {\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.alignFill_;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.instructions = instructions.instructions;\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    this.coordinates = instructions.coordinates;\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n\n    this.coordinateCache_ = {};\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n\n    this.renderedTransform_ = createTransform();\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.pixelCoordinates_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.viewRotation_ = 0;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n\n    this.fillStates = instructions.fillStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n\n    this.strokeStates = instructions.strokeStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n\n    this.textStates = instructions.textStates || {};\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n\n    this.widths_ = {};\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n\n    this.labels_ = {};\n  }\n  /**\n   * @param {string|Array<string>} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n\n\n  Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {\n    var key = text + textKey + fillKey + strokeKey;\n\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n\n    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    var fillState = fillKey ? this.fillStates[fillKey] : null;\n    var textState = this.textStates[textKey];\n    var pixelRatio = this.pixelRatio;\n    var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];\n    var textIsArray = Array.isArray(text);\n    var align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);\n    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var chunks = textIsArray ? text : text.split('\\n').reduce(createTextChunks, []);\n\n    var _a = getTextDimensions(textState, chunks),\n        width = _a.width,\n        height = _a.height,\n        widths = _a.widths,\n        heights = _a.heights,\n        lineWidths = _a.lineWidths;\n\n    var renderWidth = width + strokeWidth;\n    var contextInstructions = []; // make canvas 2 pixels wider to account for italic text width measurement errors\n\n    var w = (renderWidth + 2) * scale[0];\n    var h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n\n    var label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions\n    };\n\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit); // eslint-disable-next-line\n\n      var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n\n      if (Context.prototype.setLineDash) {\n        contextInstructions.push('setLineDash', [strokeState.lineDash]);\n        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n      }\n    }\n\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    var leftRight = 0.5 - align;\n    var x = align * renderWidth + leftRight * strokeWidth;\n    var strokeInstructions = [];\n    var fillInstructions = [];\n    var lineHeight = 0;\n    var lineOffset = 0;\n    var widthHeightIndex = 0;\n    var lineWidthIndex = 0;\n    var previousFont;\n\n    for (var i = 0, ii = chunks.length; i < ii; i += 2) {\n      var text_1 = chunks[i];\n\n      if (text_1 === '\\n') {\n        lineOffset += lineHeight;\n        lineHeight = 0;\n        x = align * renderWidth + leftRight * strokeWidth;\n        ++lineWidthIndex;\n        continue;\n      }\n\n      var font = chunks[i + 1] || textState.font;\n\n      if (font !== previousFont) {\n        if (strokeKey) {\n          strokeInstructions.push('font', font);\n        }\n\n        if (fillKey) {\n          fillInstructions.push('font', font);\n        }\n\n        previousFont = font;\n      }\n\n      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);\n      var fillStrokeArgs = [text_1, x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]), 0.5 * (strokeWidth + lineHeight) + lineOffset];\n      x += widths[widthHeightIndex];\n\n      if (strokeKey) {\n        strokeInstructions.push('strokeText', fillStrokeArgs);\n      }\n\n      if (fillKey) {\n        fillInstructions.push('fillText', fillStrokeArgs);\n      }\n\n      ++widthHeightIndex;\n    }\n\n    Array.prototype.push.apply(contextInstructions, strokeInstructions);\n    Array.prototype.push.apply(contextInstructions, fillInstructions);\n    this.labels_[key] = label;\n    return label;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n\n\n  Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n\n    if (fillInstruction) {\n      this.alignFill_ =\n      /** @type {boolean} */\n      fillInstruction[2];\n      this.fill_(context);\n    }\n\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context,\n      /** @type {Array<*>} */\n      strokeInstruction);\n      context.stroke();\n    }\n  };\n  /**\n   * @private\n   * @param {number} sheetWidth Width of the sprite sheet.\n   * @param {number} sheetHeight Height of the sprite sheet.\n   * @param {number} centerX X.\n   * @param {number} centerY Y.\n   * @param {number} width Width.\n   * @param {number} height Height.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {import(\"../../size.js\").Size} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {Array<number>} padding Padding.\n   * @param {boolean} fillStroke Background fill or stroke.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\n   */\n\n\n  Executor.prototype.calculateImageOrLabelDimensions_ = function (sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    var x = centerX - anchorX;\n    var y = centerY - anchorY;\n    var w = width + originX > sheetWidth ? sheetWidth - originX : width;\n    var h = height + originY > sheetHeight ? sheetHeight - originY : height;\n    var boxW = padding[3] + w * scale[0] + padding[1];\n    var boxH = padding[0] + h * scale[1] + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n\n    var transform;\n\n    if (rotation !== 0) {\n      transform = composeTransform(createTransform(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      applyTransform(transform, p1);\n      applyTransform(transform, p2);\n      applyTransform(transform, p3);\n      applyTransform(transform, p4);\n      createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n    } else {\n      createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);\n    }\n\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    return {\n      drawImageX: x,\n      drawImageY: y,\n      drawImageW: w,\n      drawImageH: h,\n      originX: originX,\n      originY: originY,\n      declutterBox: {\n        minX: tmpExtent[0],\n        minY: tmpExtent[1],\n        maxX: tmpExtent[2],\n        maxY: tmpExtent[3],\n        value: feature\n      },\n      canvasTransform: transform,\n      scale: scale\n    };\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n   * @param {ImageOrLabelDimensions} dimensions Dimensions.\n   * @param {number} opacity Opacity.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @return {boolean} The image or label was rendered.\n   */\n\n\n  Executor.prototype.replayImageOrLabel_ = function (context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {\n    var fillStroke = !!(fillInstruction || strokeInstruction);\n    var box = dimensions.declutterBox;\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;\n    var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;\n\n    if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4,\n        /** @type {Array<*>} */\n        fillInstruction,\n        /** @type {Array<*>} */\n        strokeInstruction);\n      }\n\n      drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n\n\n  Executor.prototype.fill_ = function (context) {\n    if (this.alignFill_) {\n      var origin_1 = applyTransform(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n\n    context.fill();\n\n    if (this.alignFill_) {\n      context.restore();\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n\n\n  Executor.prototype.setStrokeStyle_ = function (context, instruction) {\n    context['strokeStyle'] =\n    /** @type {import(\"../../colorlike.js\").ColorLike} */\n    instruction[1];\n    context.lineWidth =\n    /** @type {number} */\n    instruction[2];\n    context.lineCap =\n    /** @type {CanvasLineCap} */\n    instruction[3];\n    context.lineJoin =\n    /** @type {CanvasLineJoin} */\n    instruction[4];\n    context.miterLimit =\n    /** @type {number} */\n    instruction[5];\n\n    if (context.setLineDash) {\n      context.lineDashOffset =\n      /** @type {number} */\n      instruction[7];\n      context.setLineDash(\n      /** @type {Array<number>} */\n      instruction[6]);\n    }\n  };\n  /**\n   * @private\n   * @param {string|Array<string>} text The text to draw.\n   * @param {string} textKey The key of the text state.\n   * @param {string} strokeKey The key for the stroke state.\n   * @param {string} fillKey The key for the fill state.\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n   */\n\n\n  Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {\n    var textState = this.textStates[textKey];\n    var label = this.createLabel(text, textKey, fillKey, strokeKey);\n    var strokeState = this.strokeStates[strokeKey];\n    var pixelRatio = this.pixelRatio;\n    var align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);\n    var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0; // Remove the 2 pixels we added in createLabel() for the anchor\n\n    var width = label.width / pixelRatio - 2 * textState.scale[0];\n    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY\n    };\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n   *     features that intersect this extent.\n   * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {\n    /** @type {Array<number>} */\n    var pixelCoordinates;\n\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n\n      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n\n    var i = 0; // instruction index\n\n    var ii = instructions.length; // end of instructions\n\n    var d = 0; // data index\n\n    var dd; // end of per-instruction data\n\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n    var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n    var state =\n    /** @type {import(\"../../render.js\").State} */\n    {\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    }; // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var\n    /** @type {import(\"../../Feature.js\").FeatureLike} */\n    feature;\n    var x, y, currentGeometry;\n\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type =\n      /** @type {import(\"./Instruction.js\").default} */\n      instruction[0];\n\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature =\n          /** @type {import(\"../../Feature.js\").FeatureLike} */\n          instruction[1];\n          currentGeometry = instruction[3];\n\n          if (!feature.getGeometry()) {\n            i =\n            /** @type {number} */\n            instruction[2];\n          } else if (opt_hitExtent !== undefined && !intersects(opt_hitExtent, currentGeometry.getExtent())) {\n            i =\n            /** @type {number} */\n            instruction[2] + 1;\n          } else {\n            ++i;\n          }\n\n          break;\n\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.CIRCLE:\n          d =\n          /** @type {number} */\n          instruction[1];\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n\n        case CanvasInstruction.CUSTOM:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd = instruction[2];\n          var geometry =\n          /** @type {import(\"../../geom/SimpleGeometry.js\").default} */\n          instruction[3];\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n\n          var coords = coordinateCache[i];\n\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n\n          renderer(coords, state);\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_IMAGE:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd =\n          /** @type {number} */\n          instruction[2];\n          image =\n          /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n          instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order\n\n          anchorX =\n          /** @type {number} */\n          instruction[4];\n          anchorY =\n          /** @type {number} */\n          instruction[5];\n          var height =\n          /** @type {number} */\n          instruction[6];\n          var opacity =\n          /** @type {number} */\n          instruction[7];\n          var originX =\n          /** @type {number} */\n          instruction[8];\n          var originY =\n          /** @type {number} */\n          instruction[9];\n          var rotateWithView =\n          /** @type {boolean} */\n          instruction[10];\n          var rotation =\n          /** @type {number} */\n          instruction[11];\n          var scale =\n          /** @type {import(\"../../size.js\").Size} */\n          instruction[12];\n          var width =\n          /** @type {number} */\n          instruction[13];\n          var declutterMode =\n          /** @type {\"declutter\"|\"obstacle\"|\"none\"|undefined} */\n          instruction[14];\n          var declutterImageWithText =\n          /** @type {import(\"../canvas.js\").DeclutterImageWithText} */\n          instruction[15];\n\n          if (!image && instruction.length >= 20) {\n            // create label images\n            text =\n            /** @type {string} */\n            instruction[19];\n            textKey =\n            /** @type {string} */\n            instruction[20];\n            strokeKey =\n            /** @type {string} */\n            instruction[21];\n            fillKey =\n            /** @type {string} */\n            instruction[22];\n            var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            var textOffsetX =\n            /** @type {number} */\n            instruction[23];\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            var textOffsetY =\n            /** @type {number} */\n            instruction[24];\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[6] = height;\n            width = image.width;\n            instruction[13] = width;\n          }\n\n          var geometryWidths = void 0;\n\n          if (instruction.length > 25) {\n            geometryWidths =\n            /** @type {number} */\n            instruction[25];\n          }\n\n          var padding = void 0,\n              backgroundFill = void 0,\n              backgroundStroke = void 0;\n\n          if (instruction.length > 17) {\n            padding =\n            /** @type {Array<number>} */\n            instruction[16];\n            backgroundFill =\n            /** @type {boolean} */\n            instruction[17];\n            backgroundStroke =\n            /** @type {boolean} */\n            instruction[18];\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n\n          var widthIndex = 0;\n\n          for (; d < dd; d += 2) {\n            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {\n              continue;\n            }\n\n            var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);\n            /** @type {ReplayImageOrLabelArgs} */\n\n            var args = [context, contextScale, image, dimensions, opacity, backgroundFill ?\n            /** @type {Array<*>} */\n            lastFillInstruction : null, backgroundStroke ?\n            /** @type {Array<*>} */\n            lastStrokeInstruction : null];\n\n            if (opt_declutterTree) {\n              if (declutterMode === 'none') {\n                // not rendered in declutter group\n                continue;\n              } else if (declutterMode === 'obstacle') {\n                // will always be drawn, thus no collision detection, but insert as obstacle\n                opt_declutterTree.insert(dimensions.declutterBox);\n                continue;\n              } else {\n                var imageArgs = void 0;\n                var imageDeclutterBox = void 0;\n\n                if (declutterImageWithText) {\n                  var index = dd - d;\n\n                  if (!declutterImageWithText[index]) {\n                    // We now have the image for an image+text combination.\n                    declutterImageWithText[index] = args; // Don't render anything for now, wait for the text.\n\n                    continue;\n                  }\n\n                  imageArgs = declutterImageWithText[index];\n                  delete declutterImageWithText[index];\n                  imageDeclutterBox = getDeclutterBox(imageArgs);\n\n                  if (opt_declutterTree.collides(imageDeclutterBox)) {\n                    continue;\n                  }\n                }\n\n                if (opt_declutterTree.collides(dimensions.declutterBox)) {\n                  continue;\n                }\n\n                if (imageArgs) {\n                  // We now have image and text for an image+text combination.\n                  opt_declutterTree.insert(imageDeclutterBox); // Render the image before we render the text.\n\n                  this.replayImageOrLabel_.apply(this, imageArgs);\n                }\n\n                opt_declutterTree.insert(dimensions.declutterBox);\n              }\n            }\n\n            this.replayImageOrLabel_.apply(this, args);\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_CHARS:\n          var begin =\n          /** @type {number} */\n          instruction[1];\n          var end =\n          /** @type {number} */\n          instruction[2];\n          var baseline =\n          /** @type {number} */\n          instruction[3];\n          var overflow =\n          /** @type {number} */\n          instruction[4];\n          fillKey =\n          /** @type {string} */\n          instruction[5];\n          var maxAngle =\n          /** @type {number} */\n          instruction[6];\n          var measurePixelRatio =\n          /** @type {number} */\n          instruction[7];\n          var offsetY =\n          /** @type {number} */\n          instruction[8];\n          strokeKey =\n          /** @type {string} */\n          instruction[9];\n          var strokeWidth =\n          /** @type {number} */\n          instruction[10];\n          text =\n          /** @type {string} */\n          instruction[11];\n          textKey =\n          /** @type {string} */\n          instruction[12];\n          var pixelRatioScale = [\n          /** @type {number} */\n          instruction[13],\n          /** @type {number} */\n          instruction[13]];\n          var textState = this.textStates[textKey];\n          var font = textState.font;\n          var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];\n          var cachedWidths = void 0;\n\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n\n          var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);\n\n          if (overflow || textLength <= pathLength) {\n            var textAlign = this.textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n\n            drawChars: if (parts) {\n              /** @type {Array<ReplayImageOrLabelArgs>} */\n              var replayImageOrLabelArgs = [];\n              var c = void 0,\n                  cc = void 0,\n                  chars = void 0,\n                  label = void 0,\n                  part = void 0;\n\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars =\n                  /** @type {string} */\n                  part[4];\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX =\n                  /** @type {number} */\n                  part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;\n                  var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n\n                  if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n                    break drawChars;\n                  }\n\n                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);\n                }\n              }\n\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars =\n                  /** @type {string} */\n                  part[4];\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX =\n                  /** @type {number} */\n                  part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n\n                  if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n                    break drawChars;\n                  }\n\n                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);\n                }\n              }\n\n              if (opt_declutterTree) {\n                opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n              }\n\n              for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {\n                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);\n              }\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.END_GEOMETRY:\n          if (opt_featureCallback !== undefined) {\n            feature =\n            /** @type {import(\"../../Feature.js\").FeatureLike} */\n            instruction[1];\n            var result = opt_featureCallback(feature, currentGeometry);\n\n            if (result) {\n              return result;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd =\n          /** @type {number} */\n          instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle =\n          /** @type {import(\"../../colorlike.js\").ColorLike} */\n          instruction[1];\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          this.setStrokeStyle_(context,\n          /** @type {Array<*>} */\n          instruction);\n          ++i;\n          break;\n\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n\n          ++i;\n          break;\n\n        default:\n          // consume the instruction anyway, to avoid an infinite loop\n          ++i;\n          break;\n      }\n    }\n\n    if (pendingFill) {\n      this.fill_(context);\n    }\n\n    if (pendingStroke) {\n      context.stroke();\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n   */\n\n\n  Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n   *     features that intersect this extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n  };\n\n  return Executor;\n}();\n\nexport default Executor;","map":{"version":3,"names":["CanvasInstruction","TEXT_ALIGN","WORKER_OFFSCREEN_CANVAS","apply","applyTransform","compose","composeTransform","create","createTransform","setFromArray","transformSetFromArray","createEmpty","createOrUpdate","intersects","defaultPadding","defaultTextAlign","defaultTextBaseline","drawImageOrLabel","getTextDimensions","measureAndCacheTextWidth","drawTextOnPath","equals","lineStringLength","transform2D","tmpExtent","p1","p2","p3","p4","getDeclutterBox","replayImageOrLabelArgs","declutterBox","rtlRegEx","RegExp","String","fromCharCode","horizontalTextAlign","text","align","test","createTextChunks","acc","line","i","push","Executor","resolution","pixelRatio","overlaps","instructions","alignFill_","coordinates","coordinateCache_","renderedTransform_","hitDetectionInstructions","pixelCoordinates_","viewRotation_","fillStates","strokeStates","textStates","widths_","labels_","prototype","createLabel","textKey","fillKey","strokeKey","key","strokeState","fillState","textState","scale","textIsArray","Array","isArray","justify","textAlign","strokeWidth","lineWidth","chunks","split","reduce","_a","width","height","widths","heights","lineWidths","renderWidth","contextInstructions","w","h","label","Math","floor","ceil","strokeStyle","lineCap","lineJoin","miterLimit","Context","OffscreenCanvasRenderingContext2D","CanvasRenderingContext2D","setLineDash","lineDash","lineDashOffset","fillStyle","leftRight","x","strokeInstructions","fillInstructions","lineHeight","lineOffset","widthHeightIndex","lineWidthIndex","previousFont","ii","length","text_1","font","max","fillStrokeArgs","replayTextBackground_","context","fillInstruction","strokeInstruction","beginPath","moveTo","lineTo","fill_","setStrokeStyle_","stroke","calculateImageOrLabelDimensions_","sheetWidth","sheetHeight","centerX","centerY","anchorX","anchorY","originX","originY","rotation","snapToPixel","padding","fillStroke","feature","y","boxW","boxH","boxX","boxY","transform","min","round","drawImageX","drawImageY","drawImageW","drawImageH","minX","minY","maxX","maxY","value","canvasTransform","replayImageOrLabel_","contextScale","imageOrLabel","dimensions","opacity","box","canvas","strokePadding","origin_1","repeatSize","save","translate","rotate","fill","restore","instruction","drawLabelWithPointPlacement_","baseline","textBaseline","execute_","opt_featureCallback","opt_hitExtent","opt_declutterTree","pixelCoordinates","d","dd","prevX","prevY","roundX","roundY","image","pendingFill","pendingStroke","lastFillInstruction","lastStrokeInstruction","coordinateCache","viewRotation","viewRotationFromTransform","atan2","state","batchSize","currentGeometry","type","BEGIN_GEOMETRY","getGeometry","undefined","getExtent","BEGIN_PATH","NaN","CIRCLE","x1","y1","x2","y2","dx","dy","r","sqrt","arc","PI","CLOSE_PATH","closePath","CUSTOM","geometry","renderer","fn","coords","DRAW_IMAGE","rotateWithView","declutterMode","declutterImageWithText","labelWithAnchor","textOffsetX","textOffsetY","geometryWidths","backgroundFill","backgroundStroke","widthIndex","args","insert","imageArgs","imageDeclutterBox","index","collides","DRAW_CHARS","begin","end","overflow","maxAngle","measurePixelRatio","offsetY","pixelRatioScale","textScale","cachedWidths","pathLength","textLength","abs","startM","parts","drawChars","c","cc","chars","part","load","map","i_1","ii_1","END_GEOMETRY","result","FILL","MOVE_TO_LINE_TO","SET_FILL_STYLE","SET_STROKE_STYLE","STROKE","execute","executeHitDetection"],"sources":["/home/asura/github/smartcity/node_modules/ol/render/canvas/Executor.js"],"sourcesContent":["/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../../has.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray, } from '../../transform.js';\nimport { createEmpty, createOrUpdate, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextAlign, defaultTextBaseline, drawImageOrLabel, getTextDimensions, measureAndCacheTextWidth, } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @typedef {Object} BBox\n * @property {number} minX Minimal x.\n * @property {number} minY Minimal y.\n * @property {number} maxX Maximal x.\n * @property {number} maxY Maximal y\n * @property {*} value Value.\n */\n/**\n * @typedef {Object} ImageOrLabelDimensions\n * @property {number} drawImageX DrawImageX.\n * @property {number} drawImageY DrawImageY.\n * @property {number} drawImageW DrawImageW.\n * @property {number} drawImageH DrawImageH.\n * @property {number} originX OriginX.\n * @property {number} originY OriginY.\n * @property {Array<number>} scale Scale.\n * @property {BBox} declutterBox DeclutterBox.\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\n */\n/**\n * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\n */\n/**\n * @template T\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nvar tmpExtent = createEmpty();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p4 = [];\n/**\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\n * @return {BBox} Declutter bbox.\n */\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n    return replayImageOrLabelArgs[3].declutterBox;\n}\nvar rtlRegEx = new RegExp(\n/* eslint-disable prettier/prettier */\n'[' +\n    String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) +\n    String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) +\n    String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) +\n    String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) +\n    String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) +\n    ']'\n/* eslint-enable prettier/prettier */\n);\n/**\n * @param {string} text Text.\n * @param {string} align Alignment.\n * @return {number} Text alignment.\n */\nfunction horizontalTextAlign(text, align) {\n    if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {\n        align = align === 'start' ? 'left' : 'right';\n    }\n    return TEXT_ALIGN[align];\n}\n/**\n * @param {Array<string>} acc Accumulator.\n * @param {string} line Line of text.\n * @param {number} i Index\n * @return {Array<string>} Accumulator.\n */\nfunction createTextChunks(acc, line, i) {\n    if (i > 0) {\n        acc.push('\\n', '');\n    }\n    acc.push(line, '');\n    return acc;\n}\nvar Executor = /** @class */ (function () {\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {boolean} overlaps The replay can have overlapping geometries.\n     * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions\n     */\n    function Executor(resolution, pixelRatio, overlaps, instructions) {\n        /**\n         * @protected\n         * @type {boolean}\n         */\n        this.overlaps = overlaps;\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.pixelRatio = pixelRatio;\n        /**\n         * @protected\n         * @const\n         * @type {number}\n         */\n        this.resolution = resolution;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this.alignFill_;\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        this.instructions = instructions.instructions;\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        this.coordinates = instructions.coordinates;\n        /**\n         * @private\n         * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n         */\n        this.coordinateCache_ = {};\n        /**\n         * @private\n         * @type {!import(\"../../transform.js\").Transform}\n         */\n        this.renderedTransform_ = createTransform();\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        this.pixelCoordinates_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.viewRotation_ = 0;\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").FillState>}\n         */\n        this.fillStates = instructions.fillStates || {};\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n         */\n        this.strokeStates = instructions.strokeStates || {};\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").TextState>}\n         */\n        this.textStates = instructions.textStates || {};\n        /**\n         * @private\n         * @type {Object<string, Object<string, number>>}\n         */\n        this.widths_ = {};\n        /**\n         * @private\n         * @type {Object<string, import(\"../canvas.js\").Label>}\n         */\n        this.labels_ = {};\n    }\n    /**\n     * @param {string|Array<string>} text Text.\n     * @param {string} textKey Text style key.\n     * @param {string} fillKey Fill style key.\n     * @param {string} strokeKey Stroke style key.\n     * @return {import(\"../canvas.js\").Label} Label.\n     */\n    Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {\n        var key = text + textKey + fillKey + strokeKey;\n        if (this.labels_[key]) {\n            return this.labels_[key];\n        }\n        var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n        var fillState = fillKey ? this.fillStates[fillKey] : null;\n        var textState = this.textStates[textKey];\n        var pixelRatio = this.pixelRatio;\n        var scale = [\n            textState.scale[0] * pixelRatio,\n            textState.scale[1] * pixelRatio,\n        ];\n        var textIsArray = Array.isArray(text);\n        var align = textState.justify\n            ? TEXT_ALIGN[textState.justify]\n            : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);\n        var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n        var chunks = textIsArray\n            ? text\n            : text.split('\\n').reduce(createTextChunks, []);\n        var _a = getTextDimensions(textState, chunks), width = _a.width, height = _a.height, widths = _a.widths, heights = _a.heights, lineWidths = _a.lineWidths;\n        var renderWidth = width + strokeWidth;\n        var contextInstructions = [];\n        // make canvas 2 pixels wider to account for italic text width measurement errors\n        var w = (renderWidth + 2) * scale[0];\n        var h = (height + strokeWidth) * scale[1];\n        /** @type {import(\"../canvas.js\").Label} */\n        var label = {\n            width: w < 0 ? Math.floor(w) : Math.ceil(w),\n            height: h < 0 ? Math.floor(h) : Math.ceil(h),\n            contextInstructions: contextInstructions,\n        };\n        if (scale[0] != 1 || scale[1] != 1) {\n            contextInstructions.push('scale', scale);\n        }\n        if (strokeKey) {\n            contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n            contextInstructions.push('lineWidth', strokeWidth);\n            contextInstructions.push('lineCap', strokeState.lineCap);\n            contextInstructions.push('lineJoin', strokeState.lineJoin);\n            contextInstructions.push('miterLimit', strokeState.miterLimit);\n            // eslint-disable-next-line\n            var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n            if (Context.prototype.setLineDash) {\n                contextInstructions.push('setLineDash', [strokeState.lineDash]);\n                contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n            }\n        }\n        if (fillKey) {\n            contextInstructions.push('fillStyle', fillState.fillStyle);\n        }\n        contextInstructions.push('textBaseline', 'middle');\n        contextInstructions.push('textAlign', 'center');\n        var leftRight = 0.5 - align;\n        var x = align * renderWidth + leftRight * strokeWidth;\n        var strokeInstructions = [];\n        var fillInstructions = [];\n        var lineHeight = 0;\n        var lineOffset = 0;\n        var widthHeightIndex = 0;\n        var lineWidthIndex = 0;\n        var previousFont;\n        for (var i = 0, ii = chunks.length; i < ii; i += 2) {\n            var text_1 = chunks[i];\n            if (text_1 === '\\n') {\n                lineOffset += lineHeight;\n                lineHeight = 0;\n                x = align * renderWidth + leftRight * strokeWidth;\n                ++lineWidthIndex;\n                continue;\n            }\n            var font = chunks[i + 1] || textState.font;\n            if (font !== previousFont) {\n                if (strokeKey) {\n                    strokeInstructions.push('font', font);\n                }\n                if (fillKey) {\n                    fillInstructions.push('font', font);\n                }\n                previousFont = font;\n            }\n            lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);\n            var fillStrokeArgs = [\n                text_1,\n                x +\n                    leftRight * widths[widthHeightIndex] +\n                    align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),\n                0.5 * (strokeWidth + lineHeight) + lineOffset,\n            ];\n            x += widths[widthHeightIndex];\n            if (strokeKey) {\n                strokeInstructions.push('strokeText', fillStrokeArgs);\n            }\n            if (fillKey) {\n                fillInstructions.push('fillText', fillStrokeArgs);\n            }\n            ++widthHeightIndex;\n        }\n        Array.prototype.push.apply(contextInstructions, strokeInstructions);\n        Array.prototype.push.apply(contextInstructions, fillInstructions);\n        this.labels_[key] = label;\n        return label;\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n     * @param {Array<*>} fillInstruction Fill instruction.\n     * @param {Array<*>} strokeInstruction Stroke instruction.\n     */\n    Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n        context.beginPath();\n        context.moveTo.apply(context, p1);\n        context.lineTo.apply(context, p2);\n        context.lineTo.apply(context, p3);\n        context.lineTo.apply(context, p4);\n        context.lineTo.apply(context, p1);\n        if (fillInstruction) {\n            this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);\n            this.fill_(context);\n        }\n        if (strokeInstruction) {\n            this.setStrokeStyle_(context, \n            /** @type {Array<*>} */ (strokeInstruction));\n            context.stroke();\n        }\n    };\n    /**\n     * @private\n     * @param {number} sheetWidth Width of the sprite sheet.\n     * @param {number} sheetHeight Height of the sprite sheet.\n     * @param {number} centerX X.\n     * @param {number} centerY Y.\n     * @param {number} width Width.\n     * @param {number} height Height.\n     * @param {number} anchorX Anchor X.\n     * @param {number} anchorY Anchor Y.\n     * @param {number} originX Origin X.\n     * @param {number} originY Origin Y.\n     * @param {number} rotation Rotation.\n     * @param {import(\"../../size.js\").Size} scale Scale.\n     * @param {boolean} snapToPixel Snap to pixel.\n     * @param {Array<number>} padding Padding.\n     * @param {boolean} fillStroke Background fill or stroke.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\n     */\n    Executor.prototype.calculateImageOrLabelDimensions_ = function (sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {\n        anchorX *= scale[0];\n        anchorY *= scale[1];\n        var x = centerX - anchorX;\n        var y = centerY - anchorY;\n        var w = width + originX > sheetWidth ? sheetWidth - originX : width;\n        var h = height + originY > sheetHeight ? sheetHeight - originY : height;\n        var boxW = padding[3] + w * scale[0] + padding[1];\n        var boxH = padding[0] + h * scale[1] + padding[2];\n        var boxX = x - padding[3];\n        var boxY = y - padding[0];\n        if (fillStroke || rotation !== 0) {\n            p1[0] = boxX;\n            p4[0] = boxX;\n            p1[1] = boxY;\n            p2[1] = boxY;\n            p2[0] = boxX + boxW;\n            p3[0] = p2[0];\n            p3[1] = boxY + boxH;\n            p4[1] = p3[1];\n        }\n        var transform;\n        if (rotation !== 0) {\n            transform = composeTransform(createTransform(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n            applyTransform(transform, p1);\n            applyTransform(transform, p2);\n            applyTransform(transform, p3);\n            applyTransform(transform, p4);\n            createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n        }\n        else {\n            createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);\n        }\n        if (snapToPixel) {\n            x = Math.round(x);\n            y = Math.round(y);\n        }\n        return {\n            drawImageX: x,\n            drawImageY: y,\n            drawImageW: w,\n            drawImageH: h,\n            originX: originX,\n            originY: originY,\n            declutterBox: {\n                minX: tmpExtent[0],\n                minY: tmpExtent[1],\n                maxX: tmpExtent[2],\n                maxY: tmpExtent[3],\n                value: feature,\n            },\n            canvasTransform: transform,\n            scale: scale,\n        };\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n     * @param {ImageOrLabelDimensions} dimensions Dimensions.\n     * @param {number} opacity Opacity.\n     * @param {Array<*>} fillInstruction Fill instruction.\n     * @param {Array<*>} strokeInstruction Stroke instruction.\n     * @return {boolean} The image or label was rendered.\n     */\n    Executor.prototype.replayImageOrLabel_ = function (context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {\n        var fillStroke = !!(fillInstruction || strokeInstruction);\n        var box = dimensions.declutterBox;\n        var canvas = context.canvas;\n        var strokePadding = strokeInstruction\n            ? (strokeInstruction[2] * dimensions.scale[0]) / 2\n            : 0;\n        var intersects = box.minX - strokePadding <= canvas.width / contextScale &&\n            box.maxX + strokePadding >= 0 &&\n            box.minY - strokePadding <= canvas.height / contextScale &&\n            box.maxY + strokePadding >= 0;\n        if (intersects) {\n            if (fillStroke) {\n                this.replayTextBackground_(context, p1, p2, p3, p4, \n                /** @type {Array<*>} */ (fillInstruction), \n                /** @type {Array<*>} */ (strokeInstruction));\n            }\n            drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);\n        }\n        return true;\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     */\n    Executor.prototype.fill_ = function (context) {\n        if (this.alignFill_) {\n            var origin_1 = applyTransform(this.renderedTransform_, [0, 0]);\n            var repeatSize = 512 * this.pixelRatio;\n            context.save();\n            context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n            context.rotate(this.viewRotation_);\n        }\n        context.fill();\n        if (this.alignFill_) {\n            context.restore();\n        }\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {Array<*>} instruction Instruction.\n     */\n    Executor.prototype.setStrokeStyle_ = function (context, instruction) {\n        context['strokeStyle'] =\n            /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n        context.lineWidth = /** @type {number} */ (instruction[2]);\n        context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);\n        context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);\n        context.miterLimit = /** @type {number} */ (instruction[5]);\n        if (context.setLineDash) {\n            context.lineDashOffset = /** @type {number} */ (instruction[7]);\n            context.setLineDash(/** @type {Array<number>} */ (instruction[6]));\n        }\n    };\n    /**\n     * @private\n     * @param {string|Array<string>} text The text to draw.\n     * @param {string} textKey The key of the text state.\n     * @param {string} strokeKey The key for the stroke state.\n     * @param {string} fillKey The key for the fill state.\n     * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n     */\n    Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {\n        var textState = this.textStates[textKey];\n        var label = this.createLabel(text, textKey, fillKey, strokeKey);\n        var strokeState = this.strokeStates[strokeKey];\n        var pixelRatio = this.pixelRatio;\n        var align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);\n        var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n        var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n        // Remove the 2 pixels we added in createLabel() for the anchor\n        var width = label.width / pixelRatio - 2 * textState.scale[0];\n        var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n        var anchorY = (baseline * label.height) / pixelRatio +\n            2 * (0.5 - baseline) * strokeWidth;\n        return {\n            label: label,\n            anchorX: anchorX,\n            anchorY: anchorY,\n        };\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {Array<*>} instructions Instructions array.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n     * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n     *     features that intersect this extent.\n     * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {\n        /** @type {Array<number>} */\n        var pixelCoordinates;\n        if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n            pixelCoordinates = this.pixelCoordinates_;\n        }\n        else {\n            if (!this.pixelCoordinates_) {\n                this.pixelCoordinates_ = [];\n            }\n            pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n            transformSetFromArray(this.renderedTransform_, transform);\n        }\n        var i = 0; // instruction index\n        var ii = instructions.length; // end of instructions\n        var d = 0; // data index\n        var dd; // end of per-instruction data\n        var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;\n        var pendingFill = 0;\n        var pendingStroke = 0;\n        var lastFillInstruction = null;\n        var lastStrokeInstruction = null;\n        var coordinateCache = this.coordinateCache_;\n        var viewRotation = this.viewRotation_;\n        var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n        var state = /** @type {import(\"../../render.js\").State} */ ({\n            context: context,\n            pixelRatio: this.pixelRatio,\n            resolution: this.resolution,\n            rotation: viewRotation,\n        });\n        // When the batch size gets too big, performance decreases. 200 is a good\n        // balance between batch size and number of fill/stroke instructions.\n        var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n        var /** @type {import(\"../../Feature.js\").FeatureLike} */ feature;\n        var x, y, currentGeometry;\n        while (i < ii) {\n            var instruction = instructions[i];\n            var type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n            switch (type) {\n                case CanvasInstruction.BEGIN_GEOMETRY:\n                    feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (instruction[1]);\n                    currentGeometry = instruction[3];\n                    if (!feature.getGeometry()) {\n                        i = /** @type {number} */ (instruction[2]);\n                    }\n                    else if (opt_hitExtent !== undefined &&\n                        !intersects(opt_hitExtent, currentGeometry.getExtent())) {\n                        i = /** @type {number} */ (instruction[2]) + 1;\n                    }\n                    else {\n                        ++i;\n                    }\n                    break;\n                case CanvasInstruction.BEGIN_PATH:\n                    if (pendingFill > batchSize) {\n                        this.fill_(context);\n                        pendingFill = 0;\n                    }\n                    if (pendingStroke > batchSize) {\n                        context.stroke();\n                        pendingStroke = 0;\n                    }\n                    if (!pendingFill && !pendingStroke) {\n                        context.beginPath();\n                        prevX = NaN;\n                        prevY = NaN;\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.CIRCLE:\n                    d = /** @type {number} */ (instruction[1]);\n                    var x1 = pixelCoordinates[d];\n                    var y1 = pixelCoordinates[d + 1];\n                    var x2 = pixelCoordinates[d + 2];\n                    var y2 = pixelCoordinates[d + 3];\n                    var dx = x2 - x1;\n                    var dy = y2 - y1;\n                    var r = Math.sqrt(dx * dx + dy * dy);\n                    context.moveTo(x1 + r, y1);\n                    context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n                    ++i;\n                    break;\n                case CanvasInstruction.CLOSE_PATH:\n                    context.closePath();\n                    ++i;\n                    break;\n                case CanvasInstruction.CUSTOM:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = instruction[2];\n                    var geometry = \n                    /** @type {import(\"../../geom/SimpleGeometry.js\").default} */ (instruction[3]);\n                    var renderer = instruction[4];\n                    var fn = instruction.length == 6 ? instruction[5] : undefined;\n                    state.geometry = geometry;\n                    state.feature = feature;\n                    if (!(i in coordinateCache)) {\n                        coordinateCache[i] = [];\n                    }\n                    var coords = coordinateCache[i];\n                    if (fn) {\n                        fn(pixelCoordinates, d, dd, 2, coords);\n                    }\n                    else {\n                        coords[0] = pixelCoordinates[d];\n                        coords[1] = pixelCoordinates[d + 1];\n                        coords.length = 2;\n                    }\n                    renderer(coords, state);\n                    ++i;\n                    break;\n                case CanvasInstruction.DRAW_IMAGE:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = /** @type {number} */ (instruction[2]);\n                    image =\n                        /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (instruction[3]);\n                    // Remaining arguments in DRAW_IMAGE are in alphabetical order\n                    anchorX = /** @type {number} */ (instruction[4]);\n                    anchorY = /** @type {number} */ (instruction[5]);\n                    var height = /** @type {number} */ (instruction[6]);\n                    var opacity = /** @type {number} */ (instruction[7]);\n                    var originX = /** @type {number} */ (instruction[8]);\n                    var originY = /** @type {number} */ (instruction[9]);\n                    var rotateWithView = /** @type {boolean} */ (instruction[10]);\n                    var rotation = /** @type {number} */ (instruction[11]);\n                    var scale = /** @type {import(\"../../size.js\").Size} */ (instruction[12]);\n                    var width = /** @type {number} */ (instruction[13]);\n                    var declutterMode = \n                    /** @type {\"declutter\"|\"obstacle\"|\"none\"|undefined} */ (instruction[14]);\n                    var declutterImageWithText = \n                    /** @type {import(\"../canvas.js\").DeclutterImageWithText} */ (instruction[15]);\n                    if (!image && instruction.length >= 20) {\n                        // create label images\n                        text = /** @type {string} */ (instruction[19]);\n                        textKey = /** @type {string} */ (instruction[20]);\n                        strokeKey = /** @type {string} */ (instruction[21]);\n                        fillKey = /** @type {string} */ (instruction[22]);\n                        var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n                        image = labelWithAnchor.label;\n                        instruction[3] = image;\n                        var textOffsetX = /** @type {number} */ (instruction[23]);\n                        anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n                        instruction[4] = anchorX;\n                        var textOffsetY = /** @type {number} */ (instruction[24]);\n                        anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n                        instruction[5] = anchorY;\n                        height = image.height;\n                        instruction[6] = height;\n                        width = image.width;\n                        instruction[13] = width;\n                    }\n                    var geometryWidths = void 0;\n                    if (instruction.length > 25) {\n                        geometryWidths = /** @type {number} */ (instruction[25]);\n                    }\n                    var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;\n                    if (instruction.length > 17) {\n                        padding = /** @type {Array<number>} */ (instruction[16]);\n                        backgroundFill = /** @type {boolean} */ (instruction[17]);\n                        backgroundStroke = /** @type {boolean} */ (instruction[18]);\n                    }\n                    else {\n                        padding = defaultPadding;\n                        backgroundFill = false;\n                        backgroundStroke = false;\n                    }\n                    if (rotateWithView && viewRotationFromTransform) {\n                        // Canvas is expected to be rotated to reverse view rotation.\n                        rotation += viewRotation;\n                    }\n                    else if (!rotateWithView && !viewRotationFromTransform) {\n                        // Canvas is not rotated, images need to be rotated back to be north-up.\n                        rotation -= viewRotation;\n                    }\n                    var widthIndex = 0;\n                    for (; d < dd; d += 2) {\n                        if (geometryWidths &&\n                            geometryWidths[widthIndex++] < width / this.pixelRatio) {\n                            continue;\n                        }\n                        var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);\n                        /** @type {ReplayImageOrLabelArgs} */\n                        var args = [\n                            context,\n                            contextScale,\n                            image,\n                            dimensions,\n                            opacity,\n                            backgroundFill\n                                ? /** @type {Array<*>} */ (lastFillInstruction)\n                                : null,\n                            backgroundStroke\n                                ? /** @type {Array<*>} */ (lastStrokeInstruction)\n                                : null,\n                        ];\n                        if (opt_declutterTree) {\n                            if (declutterMode === 'none') {\n                                // not rendered in declutter group\n                                continue;\n                            }\n                            else if (declutterMode === 'obstacle') {\n                                // will always be drawn, thus no collision detection, but insert as obstacle\n                                opt_declutterTree.insert(dimensions.declutterBox);\n                                continue;\n                            }\n                            else {\n                                var imageArgs = void 0;\n                                var imageDeclutterBox = void 0;\n                                if (declutterImageWithText) {\n                                    var index = dd - d;\n                                    if (!declutterImageWithText[index]) {\n                                        // We now have the image for an image+text combination.\n                                        declutterImageWithText[index] = args;\n                                        // Don't render anything for now, wait for the text.\n                                        continue;\n                                    }\n                                    imageArgs = declutterImageWithText[index];\n                                    delete declutterImageWithText[index];\n                                    imageDeclutterBox = getDeclutterBox(imageArgs);\n                                    if (opt_declutterTree.collides(imageDeclutterBox)) {\n                                        continue;\n                                    }\n                                }\n                                if (opt_declutterTree.collides(dimensions.declutterBox)) {\n                                    continue;\n                                }\n                                if (imageArgs) {\n                                    // We now have image and text for an image+text combination.\n                                    opt_declutterTree.insert(imageDeclutterBox);\n                                    // Render the image before we render the text.\n                                    this.replayImageOrLabel_.apply(this, imageArgs);\n                                }\n                                opt_declutterTree.insert(dimensions.declutterBox);\n                            }\n                        }\n                        this.replayImageOrLabel_.apply(this, args);\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.DRAW_CHARS:\n                    var begin = /** @type {number} */ (instruction[1]);\n                    var end = /** @type {number} */ (instruction[2]);\n                    var baseline = /** @type {number} */ (instruction[3]);\n                    var overflow = /** @type {number} */ (instruction[4]);\n                    fillKey = /** @type {string} */ (instruction[5]);\n                    var maxAngle = /** @type {number} */ (instruction[6]);\n                    var measurePixelRatio = /** @type {number} */ (instruction[7]);\n                    var offsetY = /** @type {number} */ (instruction[8]);\n                    strokeKey = /** @type {string} */ (instruction[9]);\n                    var strokeWidth = /** @type {number} */ (instruction[10]);\n                    text = /** @type {string} */ (instruction[11]);\n                    textKey = /** @type {string} */ (instruction[12]);\n                    var pixelRatioScale = [\n                        /** @type {number} */ (instruction[13]),\n                        /** @type {number} */ (instruction[13]),\n                    ];\n                    var textState = this.textStates[textKey];\n                    var font = textState.font;\n                    var textScale = [\n                        textState.scale[0] * measurePixelRatio,\n                        textState.scale[1] * measurePixelRatio,\n                    ];\n                    var cachedWidths = void 0;\n                    if (font in this.widths_) {\n                        cachedWidths = this.widths_[font];\n                    }\n                    else {\n                        cachedWidths = {};\n                        this.widths_[font] = cachedWidths;\n                    }\n                    var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n                    var textLength = Math.abs(textScale[0]) *\n                        measureAndCacheTextWidth(font, text, cachedWidths);\n                    if (overflow || textLength <= pathLength) {\n                        var textAlign = this.textStates[textKey].textAlign;\n                        var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n                        var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n                        drawChars: if (parts) {\n                            /** @type {Array<ReplayImageOrLabelArgs>} */\n                            var replayImageOrLabelArgs = [];\n                            var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;\n                            if (strokeKey) {\n                                for (c = 0, cc = parts.length; c < cc; ++c) {\n                                    part = parts[c]; // x, y, anchorX, rotation, chunk\n                                    chars = /** @type {string} */ (part[4]);\n                                    label = this.createLabel(chars, textKey, '', strokeKey);\n                                    anchorX =\n                                        /** @type {number} */ (part[2]) +\n                                            (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                                    anchorY =\n                                        baseline * label.height +\n                                            ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /\n                                                textScale[0] -\n                                            offsetY;\n                                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n                                    if (opt_declutterTree &&\n                                        opt_declutterTree.collides(dimensions.declutterBox)) {\n                                        break drawChars;\n                                    }\n                                    replayImageOrLabelArgs.push([\n                                        context,\n                                        contextScale,\n                                        label,\n                                        dimensions,\n                                        1,\n                                        null,\n                                        null,\n                                    ]);\n                                }\n                            }\n                            if (fillKey) {\n                                for (c = 0, cc = parts.length; c < cc; ++c) {\n                                    part = parts[c]; // x, y, anchorX, rotation, chunk\n                                    chars = /** @type {string} */ (part[4]);\n                                    label = this.createLabel(chars, textKey, fillKey, '');\n                                    anchorX = /** @type {number} */ (part[2]);\n                                    anchorY = baseline * label.height - offsetY;\n                                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n                                    if (opt_declutterTree &&\n                                        opt_declutterTree.collides(dimensions.declutterBox)) {\n                                        break drawChars;\n                                    }\n                                    replayImageOrLabelArgs.push([\n                                        context,\n                                        contextScale,\n                                        label,\n                                        dimensions,\n                                        1,\n                                        null,\n                                        null,\n                                    ]);\n                                }\n                            }\n                            if (opt_declutterTree) {\n                                opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n                            }\n                            for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {\n                                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);\n                            }\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.END_GEOMETRY:\n                    if (opt_featureCallback !== undefined) {\n                        feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (instruction[1]);\n                        var result = opt_featureCallback(feature, currentGeometry);\n                        if (result) {\n                            return result;\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.FILL:\n                    if (batchSize) {\n                        pendingFill++;\n                    }\n                    else {\n                        this.fill_(context);\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.MOVE_TO_LINE_TO:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = /** @type {number} */ (instruction[2]);\n                    x = pixelCoordinates[d];\n                    y = pixelCoordinates[d + 1];\n                    roundX = (x + 0.5) | 0;\n                    roundY = (y + 0.5) | 0;\n                    if (roundX !== prevX || roundY !== prevY) {\n                        context.moveTo(x, y);\n                        prevX = roundX;\n                        prevY = roundY;\n                    }\n                    for (d += 2; d < dd; d += 2) {\n                        x = pixelCoordinates[d];\n                        y = pixelCoordinates[d + 1];\n                        roundX = (x + 0.5) | 0;\n                        roundY = (y + 0.5) | 0;\n                        if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n                            context.lineTo(x, y);\n                            prevX = roundX;\n                            prevY = roundY;\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.SET_FILL_STYLE:\n                    lastFillInstruction = instruction;\n                    this.alignFill_ = instruction[2];\n                    if (pendingFill) {\n                        this.fill_(context);\n                        pendingFill = 0;\n                        if (pendingStroke) {\n                            context.stroke();\n                            pendingStroke = 0;\n                        }\n                    }\n                    context.fillStyle =\n                        /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n                    ++i;\n                    break;\n                case CanvasInstruction.SET_STROKE_STYLE:\n                    lastStrokeInstruction = instruction;\n                    if (pendingStroke) {\n                        context.stroke();\n                        pendingStroke = 0;\n                    }\n                    this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));\n                    ++i;\n                    break;\n                case CanvasInstruction.STROKE:\n                    if (batchSize) {\n                        pendingStroke++;\n                    }\n                    else {\n                        context.stroke();\n                    }\n                    ++i;\n                    break;\n                default: // consume the instruction anyway, to avoid an infinite loop\n                    ++i;\n                    break;\n            }\n        }\n        if (pendingFill) {\n            this.fill_(context);\n        }\n        if (pendingStroke) {\n            context.stroke();\n        }\n        return undefined;\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n     */\n    Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {\n        this.viewRotation_ = viewRotation;\n        this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n     * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n     *     features that intersect this extent.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {\n        this.viewRotation_ = viewRotation;\n        return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n    };\n    return Executor;\n}());\nexport default Executor;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}