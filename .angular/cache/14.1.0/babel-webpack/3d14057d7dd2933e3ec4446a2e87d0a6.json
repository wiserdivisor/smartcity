{"ast":null,"code":"/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\n\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var x1 = 0;\n  var y1 = 0;\n  var segmentLength = 0;\n  var segmentM = 0;\n\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n\n  var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  var beginX = lerp(x1, x2, interpolate);\n  var beginY = lerp(y1, y2, interpolate);\n  var startOffset = offset - stride;\n  var startLength = segmentM;\n  var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  var endX = lerp(x1, x2, interpolate);\n  var endY = lerp(y1, y2, interpolate); // Keep text upright\n\n  var reverse;\n\n  if (rotation) {\n    var flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n\n  var PI = Math.PI;\n  var result = [];\n  var singleSegment = startOffset + stride === offset;\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n  var previousAngle; // All on the same segment\n\n  if (singleSegment) {\n    advance();\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n\n    var x = (endX + beginX) / 2;\n    var y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  } // rendering across line segments\n\n\n  text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n\n  for (var i = 0, ii = text.length; i < ii;) {\n    advance();\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n\n    previousAngle = angle;\n    var iStart = i;\n    var charLength = 0;\n\n    for (; i < ii; ++i) {\n      var index = reverse ? ii - i - 1 : i;\n      var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n\n      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {\n        break;\n      }\n\n      charLength += len;\n    }\n\n    if (i === iStart) {\n      continue;\n    }\n\n    var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);\n    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;\n    var x = lerp(x1, x2, interpolate);\n    var y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n\n  return result;\n}","map":{"version":3,"names":["lerp","rotate","drawTextOnPath","flatCoordinates","offset","end","stride","text","startM","maxAngle","scale","measureAndCacheTextWidth","font","cache","rotation","x2","y2","x1","y1","segmentLength","segmentM","advance","Math","sqrt","interpolate","beginX","beginY","startOffset","startLength","endM","endX","endY","reverse","flat","PI","result","singleSegment","previousAngle","atan2","x","y","replace","i","ii","length","angle","undefined","delta","abs","iStart","charLength","index","len","chars","substring","push"],"sources":["/home/asura/github/smartcity/node_modules/ol/geom/flat/textpath.js"],"sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var x1 = 0;\n    var y1 = 0;\n    var segmentLength = 0;\n    var segmentM = 0;\n    function advance() {\n        x1 = x2;\n        y1 = y2;\n        offset += stride;\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        segmentM += segmentLength;\n        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    do {\n        advance();\n    } while (offset < end - stride && segmentM + segmentLength < startM);\n    var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n    var beginX = lerp(x1, x2, interpolate);\n    var beginY = lerp(y1, y2, interpolate);\n    var startOffset = offset - stride;\n    var startLength = segmentM;\n    var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n    while (offset < end - stride && segmentM + segmentLength < endM) {\n        advance();\n    }\n    interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n    var endX = lerp(x1, x2, interpolate);\n    var endY = lerp(y1, y2, interpolate);\n    // Keep text upright\n    var reverse;\n    if (rotation) {\n        var flat = [beginX, beginY, endX, endY];\n        rotate(flat, 0, 4, 2, rotation, flat, flat);\n        reverse = flat[0] > flat[2];\n    }\n    else {\n        reverse = beginX > endX;\n    }\n    var PI = Math.PI;\n    var result = [];\n    var singleSegment = startOffset + stride === offset;\n    offset = startOffset;\n    segmentLength = 0;\n    segmentM = startLength;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    var previousAngle;\n    // All on the same segment\n    if (singleSegment) {\n        advance();\n        previousAngle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            previousAngle += previousAngle > 0 ? -PI : PI;\n        }\n        var x = (endX + beginX) / 2;\n        var y = (endY + beginY) / 2;\n        result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n        return result;\n    }\n    // rendering across line segments\n    text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n    for (var i = 0, ii = text.length; i < ii;) {\n        advance();\n        var angle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            angle += angle > 0 ? -PI : PI;\n        }\n        if (previousAngle !== undefined) {\n            var delta = angle - previousAngle;\n            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n            if (Math.abs(delta) > maxAngle) {\n                return null;\n            }\n        }\n        previousAngle = angle;\n        var iStart = i;\n        var charLength = 0;\n        for (; i < ii; ++i) {\n            var index = reverse ? ii - i - 1 : i;\n            var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n            if (offset + stride < end &&\n                segmentM + segmentLength < startM + charLength + len / 2) {\n                break;\n            }\n            charLength += len;\n        }\n        if (i === iStart) {\n            continue;\n        }\n        var chars = reverse\n            ? text.substring(ii - iStart, ii - i)\n            : text.substring(iStart, i);\n        interpolate =\n            segmentLength === 0\n                ? 0\n                : (startM + charLength / 2 - segmentM) / segmentLength;\n        var x = lerp(x1, x2, interpolate);\n        var y = lerp(y1, y2, interpolate);\n        result.push([x, y, charLength / 2, angle, chars]);\n        startM += charLength;\n    }\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}