{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/render/canvas/Builder\n */\n\n\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, containsCoordinate, coordinateRelationship } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\n\nvar CanvasBuilder =\n/** @class */\nfunction (_super) {\n  __extends(CanvasBuilder, _super);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n\n\n  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this = _super.call(this) || this;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n\n    _this.tolerance = tolerance;\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    _this.maxExtent = maxExtent;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.maxLineWidth = 0;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    _this.resolution = resolution;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    _this.beginGeometryInstruction1_ = null;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    _this.beginGeometryInstruction2_ = null;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    _this.bufferedMaxExtent_ = null;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    _this.instructions = [];\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    _this.coordinates = [];\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n\n    _this.tmpCoordinate_ = [];\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    _this.hitDetectionInstructions = [];\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n\n    _this.state =\n    /** @type {import(\"../canvas.js\").FillStrokeState} */\n    {};\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n\n\n  CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n      return dash * pixelRatio;\n    });\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} stride Stride.\n   * @protected\n   * @return {number} My end\n   */\n\n\n  CanvasBuilder.prototype.appendFlatPointCoordinates = function (flatCoordinates, stride) {\n    var extent = this.getBufferedMaxExtent();\n    var tmpCoord = this.tmpCoordinate_;\n    var coordinates = this.coordinates;\n    var myEnd = coordinates.length;\n\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      tmpCoord[0] = flatCoordinates[i];\n      tmpCoord[1] = flatCoordinates[i + 1];\n\n      if (containsCoordinate(extent, tmpCoord)) {\n        coordinates[myEnd++] = tmpCoord[0];\n        coordinates[myEnd++] = tmpCoord[1];\n      }\n    }\n\n    return myEnd;\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n\n\n  CanvasBuilder.prototype.appendFlatLineCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {\n    var coordinates = this.coordinates;\n    var myEnd = coordinates.length;\n    var extent = this.getBufferedMaxExtent();\n\n    if (skipFirst) {\n      offset += stride;\n    }\n\n    var lastXCoord = flatCoordinates[offset];\n    var lastYCoord = flatCoordinates[offset + 1];\n    var nextCoord = this.tmpCoordinate_;\n    var skipped = true;\n    var i, lastRel, nextRel;\n\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          coordinates[myEnd++] = lastXCoord;\n          coordinates[myEnd++] = lastYCoord;\n          skipped = false;\n        }\n\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n      } else if (nextRel === Relationship.INTERSECTING) {\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    } // Last coordinate equals first or only one point to append:\n\n\n    if (closed && skipped || i === offset + stride) {\n      coordinates[myEnd++] = lastXCoord;\n      coordinates[myEnd++] = lastYCoord;\n    }\n\n    return myEnd;\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n\n\n  CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n\n    return offset;\n  };\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {Function} renderer Renderer.\n   * @param {Function} hitDetectionRenderer Renderer.\n   */\n\n\n  CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer, hitDetectionRenderer) {\n    this.beginGeometry(geometry, feature);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var builderBegin = this.coordinates.length;\n    var flatCoordinates, builderEnd, builderEnds, builderEndss;\n    var offset;\n\n    switch (type) {\n      case 'MultiPolygon':\n        flatCoordinates =\n        /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.getOrientedFlatCoordinates();\n        builderEndss = [];\n        var endss =\n        /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.getEndss();\n        offset = 0;\n\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n          var myEnds = [];\n          offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n          builderEndss.push(myEnds);\n        }\n\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, hitDetectionRenderer || renderer, inflateMultiCoordinatesArray]);\n        break;\n\n      case 'Polygon':\n      case 'MultiLineString':\n        builderEnds = [];\n        flatCoordinates = type == 'Polygon' ?\n        /** @type {import(\"../../geom/Polygon.js\").default} */\n        geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n        offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n        /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */\n        geometry.getEnds(), stride, builderEnds);\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, inflateCoordinatesArray]);\n        break;\n\n      case 'LineString':\n      case 'Circle':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n        break;\n\n      case 'MultiPoint':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n\n        if (builderEnd > builderBegin) {\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n        }\n\n        break;\n\n      case 'Point':\n        flatCoordinates = geometry.getFlatCoordinates();\n        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n        builderEnd = this.coordinates.length;\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer]);\n        break;\n\n      default:\n    }\n\n    this.endGeometry(feature);\n  };\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n\n\n  CanvasBuilder.prototype.finish = function () {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates\n    };\n  };\n  /**\n   * Reverse the hit detection instructions.\n   */\n\n\n  CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {\n    var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array\n\n    hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks\n\n    var i;\n    var n = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type =\n      /** @type {import(\"./Instruction.js\").default} */\n      instruction[0];\n\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  };\n  /**\n   * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n   * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n   */\n\n\n  CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {\n    var state = this.state;\n\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache\n\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n\n\n  CanvasBuilder.prototype.createFill = function (state) {\n    var fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n\n    var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n\n    return fillInstruction;\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n\n\n  CanvasBuilder.prototype.applyStroke = function (state) {\n    this.instructions.push(this.createStroke(state));\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n\n\n  CanvasBuilder.prototype.createStroke = function (state) {\n    return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n\n\n  CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {\n    var fillStyle = state.fillStyle;\n\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n\n      state.currentFillStyle = fillStyle;\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n\n\n  CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  CanvasBuilder.prototype.endGeometry = function (feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n\n\n  CanvasBuilder.prototype.getBufferedMaxExtent = function () {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n\n    return this.bufferedMaxExtent_;\n  };\n\n  return CanvasBuilder;\n}(VectorContext);\n\nexport default CanvasBuilder;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","CanvasInstruction","Relationship","VectorContext","asColorLike","buffer","clone","containsCoordinate","coordinateRelationship","defaultFillStyle","defaultLineCap","defaultLineDash","defaultLineDashOffset","defaultLineJoin","defaultLineWidth","defaultMiterLimit","defaultStrokeStyle","equals","reverseSubArray","inflateCoordinates","inflateCoordinatesArray","inflateMultiCoordinatesArray","CanvasBuilder","_super","tolerance","maxExtent","resolution","pixelRatio","_this","maxLineWidth","beginGeometryInstruction1_","beginGeometryInstruction2_","bufferedMaxExtent_","instructions","coordinates","tmpCoordinate_","hitDetectionInstructions","state","applyPixelRatio","dashArray","map","dash","appendFlatPointCoordinates","flatCoordinates","stride","extent","getBufferedMaxExtent","tmpCoord","myEnd","length","i","ii","appendFlatLineCoordinates","offset","end","closed","skipFirst","lastXCoord","lastYCoord","nextCoord","skipped","lastRel","nextRel","INTERSECTING","drawCustomCoordinates_","ends","builderEnds","builderEnd","push","drawCustom","geometry","feature","renderer","hitDetectionRenderer","beginGeometry","type","getType","getStride","builderBegin","builderEndss","getOrientedFlatCoordinates","endss","getEndss","myEnds","CUSTOM","getFlatCoordinates","getEnds","endGeometry","BEGIN_GEOMETRY","finish","reverseHitDetectionInstructions","reverse","n","instruction","begin","END_GEOMETRY","setFillStrokeStyle","fillStyle","strokeStyle","fillStyleColor","getColor","undefined","strokeStyleColor","strokeStyleLineCap","getLineCap","lineCap","strokeStyleLineDash","getLineDash","lineDash","slice","strokeStyleLineDashOffset","getLineDashOffset","lineDashOffset","strokeStyleLineJoin","getLineJoin","lineJoin","strokeStyleWidth","getWidth","lineWidth","strokeStyleMiterLimit","getMiterLimit","miterLimit","createFill","fillInstruction","SET_FILL_STYLE","applyStroke","createStroke","SET_STROKE_STYLE","updateFillStyle","currentFillStyle","updateStrokeStyle","currentStrokeStyle","currentLineCap","currentLineDash","currentLineDashOffset","currentLineJoin","currentLineWidth","currentMiterLimit","endGeometryInstruction","width"],"sources":["/home/asura/github/smartcity/node_modules/ol/render/canvas/Builder.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, containsCoordinate, coordinateRelationship, } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle, } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray, } from '../../geom/flat/inflate.js';\nvar CanvasBuilder = /** @class */ (function (_super) {\n    __extends(CanvasBuilder, _super);\n    /**\n     * @param {number} tolerance Tolerance.\n     * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     */\n    function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n        var _this = _super.call(this) || this;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.tolerance = tolerance;\n        /**\n         * @protected\n         * @const\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.maxExtent = maxExtent;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.pixelRatio = pixelRatio;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.maxLineWidth = 0;\n        /**\n         * @protected\n         * @const\n         * @type {number}\n         */\n        _this.resolution = resolution;\n        /**\n         * @private\n         * @type {Array<*>}\n         */\n        _this.beginGeometryInstruction1_ = null;\n        /**\n         * @private\n         * @type {Array<*>}\n         */\n        _this.beginGeometryInstruction2_ = null;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.bufferedMaxExtent_ = null;\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        _this.instructions = [];\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        _this.coordinates = [];\n        /**\n         * @private\n         * @type {import(\"../../coordinate.js\").Coordinate}\n         */\n        _this.tmpCoordinate_ = [];\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        _this.hitDetectionInstructions = [];\n        /**\n         * @protected\n         * @type {import(\"../canvas.js\").FillStrokeState}\n         */\n        _this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */ ({});\n        return _this;\n    }\n    /**\n     * @protected\n     * @param {Array<number>} dashArray Dash array.\n     * @return {Array<number>} Dash array with pixel ratio applied\n     */\n    CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {\n        var pixelRatio = this.pixelRatio;\n        return pixelRatio == 1\n            ? dashArray\n            : dashArray.map(function (dash) {\n                return dash * pixelRatio;\n            });\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} stride Stride.\n     * @protected\n     * @return {number} My end\n     */\n    CanvasBuilder.prototype.appendFlatPointCoordinates = function (flatCoordinates, stride) {\n        var extent = this.getBufferedMaxExtent();\n        var tmpCoord = this.tmpCoordinate_;\n        var coordinates = this.coordinates;\n        var myEnd = coordinates.length;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            tmpCoord[0] = flatCoordinates[i];\n            tmpCoord[1] = flatCoordinates[i + 1];\n            if (containsCoordinate(extent, tmpCoord)) {\n                coordinates[myEnd++] = tmpCoord[0];\n                coordinates[myEnd++] = tmpCoord[1];\n            }\n        }\n        return myEnd;\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {boolean} closed Last input coordinate equals first.\n     * @param {boolean} skipFirst Skip first coordinate.\n     * @protected\n     * @return {number} My end.\n     */\n    CanvasBuilder.prototype.appendFlatLineCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {\n        var coordinates = this.coordinates;\n        var myEnd = coordinates.length;\n        var extent = this.getBufferedMaxExtent();\n        if (skipFirst) {\n            offset += stride;\n        }\n        var lastXCoord = flatCoordinates[offset];\n        var lastYCoord = flatCoordinates[offset + 1];\n        var nextCoord = this.tmpCoordinate_;\n        var skipped = true;\n        var i, lastRel, nextRel;\n        for (i = offset + stride; i < end; i += stride) {\n            nextCoord[0] = flatCoordinates[i];\n            nextCoord[1] = flatCoordinates[i + 1];\n            nextRel = coordinateRelationship(extent, nextCoord);\n            if (nextRel !== lastRel) {\n                if (skipped) {\n                    coordinates[myEnd++] = lastXCoord;\n                    coordinates[myEnd++] = lastYCoord;\n                    skipped = false;\n                }\n                coordinates[myEnd++] = nextCoord[0];\n                coordinates[myEnd++] = nextCoord[1];\n            }\n            else if (nextRel === Relationship.INTERSECTING) {\n                coordinates[myEnd++] = nextCoord[0];\n                coordinates[myEnd++] = nextCoord[1];\n                skipped = false;\n            }\n            else {\n                skipped = true;\n            }\n            lastXCoord = nextCoord[0];\n            lastYCoord = nextCoord[1];\n            lastRel = nextRel;\n        }\n        // Last coordinate equals first or only one point to append:\n        if ((closed && skipped) || i === offset + stride) {\n            coordinates[myEnd++] = lastXCoord;\n            coordinates[myEnd++] = lastYCoord;\n        }\n        return myEnd;\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {Array<number>} builderEnds Builder ends.\n     * @return {number} Offset.\n     */\n    CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n            builderEnds.push(builderEnd);\n            offset = end;\n        }\n        return offset;\n    };\n    /**\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {Function} renderer Renderer.\n     * @param {Function} hitDetectionRenderer Renderer.\n     */\n    CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer, hitDetectionRenderer) {\n        this.beginGeometry(geometry, feature);\n        var type = geometry.getType();\n        var stride = geometry.getStride();\n        var builderBegin = this.coordinates.length;\n        var flatCoordinates, builderEnd, builderEnds, builderEndss;\n        var offset;\n        switch (type) {\n            case 'MultiPolygon':\n                flatCoordinates =\n                    /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry).getOrientedFlatCoordinates();\n                builderEndss = [];\n                var endss = \n                /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry).getEndss();\n                offset = 0;\n                for (var i = 0, ii = endss.length; i < ii; ++i) {\n                    var myEnds = [];\n                    offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n                    builderEndss.push(myEnds);\n                }\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEndss,\n                    geometry,\n                    renderer,\n                    inflateMultiCoordinatesArray,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEndss,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                    inflateMultiCoordinatesArray,\n                ]);\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                builderEnds = [];\n                flatCoordinates =\n                    type == 'Polygon'\n                        ? /** @type {import(\"../../geom/Polygon.js\").default} */ (geometry).getOrientedFlatCoordinates()\n                        : geometry.getFlatCoordinates();\n                offset = this.drawCustomCoordinates_(flatCoordinates, 0, \n                /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */ (geometry).getEnds(), stride, builderEnds);\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnds,\n                    geometry,\n                    renderer,\n                    inflateCoordinatesArray,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnds,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                    inflateCoordinatesArray,\n                ]);\n                break;\n            case 'LineString':\n            case 'Circle':\n                flatCoordinates = geometry.getFlatCoordinates();\n                builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    renderer,\n                    inflateCoordinates,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                    inflateCoordinates,\n                ]);\n                break;\n            case 'MultiPoint':\n                flatCoordinates = geometry.getFlatCoordinates();\n                builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n                if (builderEnd > builderBegin) {\n                    this.instructions.push([\n                        CanvasInstruction.CUSTOM,\n                        builderBegin,\n                        builderEnd,\n                        geometry,\n                        renderer,\n                        inflateCoordinates,\n                    ]);\n                    this.hitDetectionInstructions.push([\n                        CanvasInstruction.CUSTOM,\n                        builderBegin,\n                        builderEnd,\n                        geometry,\n                        hitDetectionRenderer || renderer,\n                        inflateCoordinates,\n                    ]);\n                }\n                break;\n            case 'Point':\n                flatCoordinates = geometry.getFlatCoordinates();\n                this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n                builderEnd = this.coordinates.length;\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    renderer,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                ]);\n                break;\n            default:\n        }\n        this.endGeometry(feature);\n    };\n    /**\n     * @protected\n     * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {\n        this.beginGeometryInstruction1_ = [\n            CanvasInstruction.BEGIN_GEOMETRY,\n            feature,\n            0,\n            geometry,\n        ];\n        this.instructions.push(this.beginGeometryInstruction1_);\n        this.beginGeometryInstruction2_ = [\n            CanvasInstruction.BEGIN_GEOMETRY,\n            feature,\n            0,\n            geometry,\n        ];\n        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n    };\n    /**\n     * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n     */\n    CanvasBuilder.prototype.finish = function () {\n        return {\n            instructions: this.instructions,\n            hitDetectionInstructions: this.hitDetectionInstructions,\n            coordinates: this.coordinates,\n        };\n    };\n    /**\n     * Reverse the hit detection instructions.\n     */\n    CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {\n        var hitDetectionInstructions = this.hitDetectionInstructions;\n        // step 1 - reverse array\n        hitDetectionInstructions.reverse();\n        // step 2 - reverse instructions within geometry blocks\n        var i;\n        var n = hitDetectionInstructions.length;\n        var instruction;\n        var type;\n        var begin = -1;\n        for (i = 0; i < n; ++i) {\n            instruction = hitDetectionInstructions[i];\n            type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n            if (type == CanvasInstruction.END_GEOMETRY) {\n                begin = i;\n            }\n            else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n                instruction[2] = i;\n                reverseSubArray(this.hitDetectionInstructions, begin, i);\n                begin = -1;\n            }\n        }\n    };\n    /**\n     * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n     * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n     */\n    CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {\n        var state = this.state;\n        if (fillStyle) {\n            var fillStyleColor = fillStyle.getColor();\n            state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n        }\n        else {\n            state.fillStyle = undefined;\n        }\n        if (strokeStyle) {\n            var strokeStyleColor = strokeStyle.getColor();\n            state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n            var strokeStyleLineCap = strokeStyle.getLineCap();\n            state.lineCap =\n                strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n            var strokeStyleLineDash = strokeStyle.getLineDash();\n            state.lineDash = strokeStyleLineDash\n                ? strokeStyleLineDash.slice()\n                : defaultLineDash;\n            var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n            state.lineDashOffset = strokeStyleLineDashOffset\n                ? strokeStyleLineDashOffset\n                : defaultLineDashOffset;\n            var strokeStyleLineJoin = strokeStyle.getLineJoin();\n            state.lineJoin =\n                strokeStyleLineJoin !== undefined\n                    ? strokeStyleLineJoin\n                    : defaultLineJoin;\n            var strokeStyleWidth = strokeStyle.getWidth();\n            state.lineWidth =\n                strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n            var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n            state.miterLimit =\n                strokeStyleMiterLimit !== undefined\n                    ? strokeStyleMiterLimit\n                    : defaultMiterLimit;\n            if (state.lineWidth > this.maxLineWidth) {\n                this.maxLineWidth = state.lineWidth;\n                // invalidate the buffered max extent cache\n                this.bufferedMaxExtent_ = null;\n            }\n        }\n        else {\n            state.strokeStyle = undefined;\n            state.lineCap = undefined;\n            state.lineDash = null;\n            state.lineDashOffset = undefined;\n            state.lineJoin = undefined;\n            state.lineWidth = undefined;\n            state.miterLimit = undefined;\n        }\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Fill instruction.\n     */\n    CanvasBuilder.prototype.createFill = function (state) {\n        var fillStyle = state.fillStyle;\n        /** @type {Array<*>} */\n        var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n        if (typeof fillStyle !== 'string') {\n            // Fill is a pattern or gradient - align it!\n            fillInstruction.push(true);\n        }\n        return fillInstruction;\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     */\n    CanvasBuilder.prototype.applyStroke = function (state) {\n        this.instructions.push(this.createStroke(state));\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Stroke instruction.\n     */\n    CanvasBuilder.prototype.createStroke = function (state) {\n        return [\n            CanvasInstruction.SET_STROKE_STYLE,\n            state.strokeStyle,\n            state.lineWidth * this.pixelRatio,\n            state.lineCap,\n            state.lineJoin,\n            state.miterLimit,\n            this.applyPixelRatio(state.lineDash),\n            state.lineDashOffset * this.pixelRatio,\n        ];\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n     */\n    CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {\n        var fillStyle = state.fillStyle;\n        if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n            if (fillStyle !== undefined) {\n                this.instructions.push(createFill.call(this, state));\n            }\n            state.currentFillStyle = fillStyle;\n        }\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n     */\n    CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {\n        var strokeStyle = state.strokeStyle;\n        var lineCap = state.lineCap;\n        var lineDash = state.lineDash;\n        var lineDashOffset = state.lineDashOffset;\n        var lineJoin = state.lineJoin;\n        var lineWidth = state.lineWidth;\n        var miterLimit = state.miterLimit;\n        if (state.currentStrokeStyle != strokeStyle ||\n            state.currentLineCap != lineCap ||\n            (lineDash != state.currentLineDash &&\n                !equals(state.currentLineDash, lineDash)) ||\n            state.currentLineDashOffset != lineDashOffset ||\n            state.currentLineJoin != lineJoin ||\n            state.currentLineWidth != lineWidth ||\n            state.currentMiterLimit != miterLimit) {\n            if (strokeStyle !== undefined) {\n                applyStroke.call(this, state);\n            }\n            state.currentStrokeStyle = strokeStyle;\n            state.currentLineCap = lineCap;\n            state.currentLineDash = lineDash;\n            state.currentLineDashOffset = lineDashOffset;\n            state.currentLineJoin = lineJoin;\n            state.currentLineWidth = lineWidth;\n            state.currentMiterLimit = miterLimit;\n        }\n    };\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasBuilder.prototype.endGeometry = function (feature) {\n        this.beginGeometryInstruction1_[2] = this.instructions.length;\n        this.beginGeometryInstruction1_ = null;\n        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n        this.beginGeometryInstruction2_ = null;\n        var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n        this.instructions.push(endGeometryInstruction);\n        this.hitDetectionInstructions.push(endGeometryInstruction);\n    };\n    /**\n     * Get the buffered rendering extent.  Rendering will be clipped to the extent\n     * provided to the constructor.  To account for symbolizers that may intersect\n     * this extent, we calculate a buffered extent (e.g. based on stroke width).\n     * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n     * @protected\n     */\n    CanvasBuilder.prototype.getBufferedMaxExtent = function () {\n        if (!this.bufferedMaxExtent_) {\n            this.bufferedMaxExtent_ = clone(this.maxExtent);\n            if (this.maxLineWidth > 0) {\n                var width = (this.resolution * (this.maxLineWidth + 1)) / 2;\n                buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n            }\n        }\n        return this.bufferedMaxExtent_;\n    };\n    return CanvasBuilder;\n}(VectorContext));\nexport default CanvasBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}