{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/reproj/Tile\n */\n\n\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\n\nvar ReprojTile =\n/** @class */\nfunction (_super) {\n  __extends(ReprojTile, _super);\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [opt_renderEdges] Render reprojection edges.\n   * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.\n   */\n\n\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {\n    var _this = _super.call(this, tileCoord, TileState.IDLE, {\n      interpolate: !!opt_interpolate\n    }) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n\n    _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.gutter_ = gutter;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    _this.canvas_ = null;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n\n    _this.sourceTileGrid_ = sourceTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n\n    _this.targetTileGrid_ = targetTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n\n    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n\n    _this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n\n    _this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n\n    var sourceProjExtent = sourceProj.getExtent();\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n\n    _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n\n    if (_this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n\n    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      _this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n\n          if (tile) {\n            _this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = TileState.EMPTY;\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n\n\n  ReprojTile.prototype.getImage = function () {\n    return this.canvas_;\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojTile.prototype.reproject_ = function () {\n    var sources = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n      this.state = TileState.LOADED;\n    }\n\n    this.changed();\n  };\n  /**\n   * Load not yet loaded URI.\n   */\n\n\n  ReprojTile.prototype.load = function () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      var leftToLoad_1 = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad_1++;\n          var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n            var state = tile.getState();\n\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey_1);\n              leftToLoad_1--;\n\n              if (leftToLoad_1 === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey_1);\n        }\n      }.bind(this));\n\n      if (leftToLoad_1 === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          var state = tile.getState();\n\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojTile.prototype.unlistenSources_ = function () {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n  /**\n   * Remove from the cache due to expiry\n   */\n\n\n  ReprojTile.prototype.release = function () {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n\n    _super.prototype.release.call(this);\n  };\n\n  return ReprojTile;\n}(Tile);\n\nexport default ReprojTile;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","ERROR_THRESHOLD","EventType","Tile","TileState","Triangulation","calculateSourceExtentResolution","canvasPool","render","renderReprojected","clamp","getArea","getIntersection","listen","unlistenByKey","releaseCanvas","ReprojTile","_super","sourceProj","sourceTileGrid","targetProj","targetTileGrid","tileCoord","wrappedTileCoord","pixelRatio","gutter","getTileFunction","opt_errorThreshold","opt_renderEdges","opt_interpolate","_this","IDLE","interpolate","renderEdges_","undefined","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","getTileCoordExtent","maxTargetExtent","getExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","sourceProjExtent","targetResolution","getResolution","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","canWrapX","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","push","getImage","reproject_","sources","forEach","i","arr","getState","LOADED","extent","image","bind","ERROR","z","size","getTileSize","width","height","changed","load","LOADING","leftToLoad_1","sourceListenKey_1","CHANGE","e","unlistenSources_","setTimeout","release","getContext"],"sources":["/home/asura/github/smartcity/node_modules/ol/reproj/Tile.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected, } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */ (function (_super) {\n    __extends(ReprojTile, _super);\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n     * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {number} gutter Gutter of the source tiles.\n     * @param {FunctionType} getTileFunction\n     *     Function returning source tiles (z, x, y, pixelRatio).\n     * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n     * @param {boolean} [opt_renderEdges] Render reprojection edges.\n     * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.\n     */\n    function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {\n        var _this = _super.call(this, tileCoord, TileState.IDLE, { interpolate: !!opt_interpolate }) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.gutter_ = gutter;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.canvas_ = null;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.sourceTileGrid_ = sourceTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.targetTileGrid_ = targetTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilecoord.js\").TileCoord}\n         */\n        _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n        /**\n         * @private\n         * @type {!Array<import(\"../Tile.js\").default>}\n         */\n        _this.sourceTiles_ = [];\n        /**\n         * @private\n         * @type {?Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.sourcesListenerKeys_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.sourceZ_ = 0;\n        var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n        var maxTargetExtent = _this.targetTileGrid_.getExtent();\n        var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n        var limitedTargetExtent = maxTargetExtent\n            ? getIntersection(targetExtent, maxTargetExtent)\n            : targetExtent;\n        if (getArea(limitedTargetExtent) === 0) {\n            // Tile is completely outside range -> EMPTY\n            // TODO: is it actually correct that the source even creates the tile ?\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var sourceProjExtent = sourceProj.getExtent();\n        if (sourceProjExtent) {\n            if (!maxSourceExtent) {\n                maxSourceExtent = sourceProjExtent;\n            }\n            else {\n                maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n            }\n        }\n        var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n        var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n        if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n            // invalid sourceResolution -> EMPTY\n            // probably edges of the projections when no extent is defined\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n        /**\n         * @private\n         * @type {!import(\"./Triangulation.js\").default}\n         */\n        _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n        if (_this.triangulation_.getTriangles().length === 0) {\n            // no valid triangles -> EMPTY\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n        var sourceExtent = _this.triangulation_.calculateSourceExtent();\n        if (maxSourceExtent) {\n            if (sourceProj.canWrapX()) {\n                sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n                sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n            }\n            else {\n                sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n            }\n        }\n        if (!getArea(sourceExtent)) {\n            _this.state = TileState.EMPTY;\n        }\n        else {\n            var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n            for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n                for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n                    var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n                    if (tile) {\n                        _this.sourceTiles_.push(tile);\n                    }\n                }\n            }\n            if (_this.sourceTiles_.length === 0) {\n                _this.state = TileState.EMPTY;\n            }\n        }\n        return _this;\n    }\n    /**\n     * Get the HTML Canvas element for this tile.\n     * @return {HTMLCanvasElement} Canvas.\n     */\n    ReprojTile.prototype.getImage = function () {\n        return this.canvas_;\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.reproject_ = function () {\n        var sources = [];\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n            if (tile && tile.getState() == TileState.LOADED) {\n                sources.push({\n                    extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n                    image: tile.getImage(),\n                });\n            }\n        }.bind(this));\n        this.sourceTiles_.length = 0;\n        if (sources.length === 0) {\n            this.state = TileState.ERROR;\n        }\n        else {\n            var z = this.wrappedTileCoord_[0];\n            var size = this.targetTileGrid_.getTileSize(z);\n            var width = typeof size === 'number' ? size : size[0];\n            var height = typeof size === 'number' ? size : size[1];\n            var targetResolution = this.targetTileGrid_.getResolution(z);\n            var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n            var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n            this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n            this.state = TileState.LOADED;\n        }\n        this.changed();\n    };\n    /**\n     * Load not yet loaded URI.\n     */\n    ReprojTile.prototype.load = function () {\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            this.changed();\n            var leftToLoad_1 = 0;\n            this.sourcesListenerKeys_ = [];\n            this.sourceTiles_.forEach(function (tile, i, arr) {\n                var state = tile.getState();\n                if (state == TileState.IDLE || state == TileState.LOADING) {\n                    leftToLoad_1++;\n                    var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n                        var state = tile.getState();\n                        if (state == TileState.LOADED ||\n                            state == TileState.ERROR ||\n                            state == TileState.EMPTY) {\n                            unlistenByKey(sourceListenKey_1);\n                            leftToLoad_1--;\n                            if (leftToLoad_1 === 0) {\n                                this.unlistenSources_();\n                                this.reproject_();\n                            }\n                        }\n                    }, this);\n                    this.sourcesListenerKeys_.push(sourceListenKey_1);\n                }\n            }.bind(this));\n            if (leftToLoad_1 === 0) {\n                setTimeout(this.reproject_.bind(this), 0);\n            }\n            else {\n                this.sourceTiles_.forEach(function (tile, i, arr) {\n                    var state = tile.getState();\n                    if (state == TileState.IDLE) {\n                        tile.load();\n                    }\n                });\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.unlistenSources_ = function () {\n        this.sourcesListenerKeys_.forEach(unlistenByKey);\n        this.sourcesListenerKeys_ = null;\n    };\n    /**\n     * Remove from the cache due to expiry\n     */\n    ReprojTile.prototype.release = function () {\n        if (this.canvas_) {\n            releaseCanvas(this.canvas_.getContext('2d'));\n            canvasPool.push(this.canvas_);\n            this.canvas_ = null;\n        }\n        _super.prototype.release.call(this);\n    };\n    return ReprojTile;\n}(Tile));\nexport default ReprojTile;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}