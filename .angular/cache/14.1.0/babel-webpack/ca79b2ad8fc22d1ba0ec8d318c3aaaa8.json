{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/PinchRotate\n */\n\n\nimport PointerInteraction, { centroid as centroidFromPointers } from './Pointer.js';\nimport { FALSE } from '../functions.js';\nimport { disable } from '../rotationconstraint.js';\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] The duration of the animation in\n * milliseconds.\n * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\n */\n\n/**\n * @classdesc\n * Allows the user to rotate the map by twisting with two fingers\n * on a touch screen.\n * @api\n */\n\nvar PinchRotate =\n/** @class */\nfunction (_super) {\n  __extends(PinchRotate, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n\n\n  function PinchRotate(opt_options) {\n    var _this = this;\n\n    var options = opt_options ? opt_options : {};\n    var pointerOptions =\n    /** @type {import(\"./Pointer.js\").Options} */\n    options;\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    _this = _super.call(this, pointerOptions) || this;\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n\n    _this.anchor_ = null;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    _this.lastAngle_ = undefined;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.rotating_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.rotationDelta_ = 0.0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.duration_ = options.duration !== undefined ? options.duration : 250;\n    return _this;\n  }\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n\n\n  PinchRotate.prototype.handleDragEvent = function (mapBrowserEvent) {\n    var rotationDelta = 0.0;\n    var touch0 = this.targetPointers[0];\n    var touch1 = this.targetPointers[1]; // angle between touches\n\n    var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);\n\n    if (this.lastAngle_ !== undefined) {\n      var delta = angle - this.lastAngle_;\n      this.rotationDelta_ += delta;\n\n      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {\n        this.rotating_ = true;\n      }\n\n      rotationDelta = delta;\n    }\n\n    this.lastAngle_ = angle;\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n\n    if (view.getConstraints().rotation === disable) {\n      return;\n    } // rotate anchor point.\n    // FIXME: should be the intersection point between the lines:\n    //     touch0,touch1 and previousTouch0,previousTouch1\n\n\n    var viewportPosition = map.getViewport().getBoundingClientRect();\n    var centroid = centroidFromPointers(this.targetPointers);\n    centroid[0] -= viewportPosition.left;\n    centroid[1] -= viewportPosition.top;\n    this.anchor_ = map.getCoordinateFromPixelInternal(centroid); // rotate\n\n    if (this.rotating_) {\n      map.render();\n      view.adjustRotationInternal(rotationDelta, this.anchor_);\n    }\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  PinchRotate.prototype.handleUpEvent = function (mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      view.endInteraction(this.duration_);\n      return false;\n    } else {\n      return true;\n    }\n  };\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  PinchRotate.prototype.handleDownEvent = function (mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      var map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastAngle_ = undefined;\n      this.rotating_ = false;\n      this.rotationDelta_ = 0.0;\n\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  return PinchRotate;\n}(PointerInteraction);\n\nexport default PinchRotate;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","PointerInteraction","centroid","centroidFromPointers","FALSE","disable","PinchRotate","_super","opt_options","_this","options","pointerOptions","stopDown","anchor_","lastAngle_","undefined","rotating_","rotationDelta_","threshold_","threshold","duration_","duration","handleDragEvent","mapBrowserEvent","rotationDelta","touch0","targetPointers","touch1","angle","Math","atan2","clientY","clientX","delta","abs","map","view","getView","getConstraints","rotation","viewportPosition","getViewport","getBoundingClientRect","left","top","getCoordinateFromPixelInternal","render","adjustRotationInternal","handleUpEvent","length","endInteraction","handleDownEvent","handlingDownUpSequence","beginInteraction"],"sources":["/home/asura/github/smartcity/node_modules/ol/interaction/PinchRotate.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/interaction/PinchRotate\n */\nimport PointerInteraction, { centroid as centroidFromPointers, } from './Pointer.js';\nimport { FALSE } from '../functions.js';\nimport { disable } from '../rotationconstraint.js';\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] The duration of the animation in\n * milliseconds.\n * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\n */\n/**\n * @classdesc\n * Allows the user to rotate the map by twisting with two fingers\n * on a touch screen.\n * @api\n */\nvar PinchRotate = /** @class */ (function (_super) {\n    __extends(PinchRotate, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function PinchRotate(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n        if (!pointerOptions.stopDown) {\n            pointerOptions.stopDown = FALSE;\n        }\n        _this = _super.call(this, pointerOptions) || this;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.anchor_ = null;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        _this.lastAngle_ = undefined;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.rotating_ = false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.rotationDelta_ = 0.0;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.duration_ = options.duration !== undefined ? options.duration : 250;\n        return _this;\n    }\n    /**\n     * Handle pointer drag events.\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n     */\n    PinchRotate.prototype.handleDragEvent = function (mapBrowserEvent) {\n        var rotationDelta = 0.0;\n        var touch0 = this.targetPointers[0];\n        var touch1 = this.targetPointers[1];\n        // angle between touches\n        var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);\n        if (this.lastAngle_ !== undefined) {\n            var delta = angle - this.lastAngle_;\n            this.rotationDelta_ += delta;\n            if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {\n                this.rotating_ = true;\n            }\n            rotationDelta = delta;\n        }\n        this.lastAngle_ = angle;\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        if (view.getConstraints().rotation === disable) {\n            return;\n        }\n        // rotate anchor point.\n        // FIXME: should be the intersection point between the lines:\n        //     touch0,touch1 and previousTouch0,previousTouch1\n        var viewportPosition = map.getViewport().getBoundingClientRect();\n        var centroid = centroidFromPointers(this.targetPointers);\n        centroid[0] -= viewportPosition.left;\n        centroid[1] -= viewportPosition.top;\n        this.anchor_ = map.getCoordinateFromPixelInternal(centroid);\n        // rotate\n        if (this.rotating_) {\n            map.render();\n            view.adjustRotationInternal(rotationDelta, this.anchor_);\n        }\n    };\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n     * @return {boolean} If the event was consumed.\n     */\n    PinchRotate.prototype.handleUpEvent = function (mapBrowserEvent) {\n        if (this.targetPointers.length < 2) {\n            var map = mapBrowserEvent.map;\n            var view = map.getView();\n            view.endInteraction(this.duration_);\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    /**\n     * Handle pointer down events.\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n     * @return {boolean} If the event was consumed.\n     */\n    PinchRotate.prototype.handleDownEvent = function (mapBrowserEvent) {\n        if (this.targetPointers.length >= 2) {\n            var map = mapBrowserEvent.map;\n            this.anchor_ = null;\n            this.lastAngle_ = undefined;\n            this.rotating_ = false;\n            this.rotationDelta_ = 0.0;\n            if (!this.handlingDownUpSequence) {\n                map.getView().beginInteraction();\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    return PinchRotate;\n}(PointerInteraction));\nexport default PinchRotate;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}