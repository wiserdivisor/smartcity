{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Snap\n */\n\n\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, squaredDistance } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { getValues } from '../obj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\n\nfunction getFeatureFromEvent(evt) {\n  if (\n  /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n  evt.feature) {\n    return (\n      /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n      evt.feature\n    );\n  } else if (\n  /** @type {import(\"../Collection.js\").CollectionEvent} */\n  evt.element) {\n    return (\n      /** @type {import(\"../Feature.js\").default} */\n\n      /** @type {import(\"../Collection.js\").CollectionEvent} */\n      evt.element\n    );\n  }\n}\n\nvar tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\n\nvar Snap =\n/** @class */\nfunction (_super) {\n  __extends(Snap, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n\n\n  function Snap(opt_options) {\n    var _this = this;\n\n    var options = opt_options ? opt_options : {};\n    var pointerOptions =\n    /** @type {import(\"./Pointer.js\").Options} */\n    options;\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    _this = _super.call(this, pointerOptions) || this;\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.edge_ = options.edge !== undefined ? options.edge : true;\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    _this.featuresListenerKeys_ = [];\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    _this.featureChangeListenerKeys_ = {};\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n\n    _this.indexedFeaturesExtents_ = {};\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n\n    _this.pendingFeatures_ = {};\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n\n    _this.rBush_ = new RBush();\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n\n    _this.GEOMETRY_SEGMENTERS_ = {\n      'Point': _this.segmentPointGeometry_.bind(_this),\n      'LineString': _this.segmentLineStringGeometry_.bind(_this),\n      'LinearRing': _this.segmentLineStringGeometry_.bind(_this),\n      'Polygon': _this.segmentPolygonGeometry_.bind(_this),\n      'MultiPoint': _this.segmentMultiPointGeometry_.bind(_this),\n      'MultiLineString': _this.segmentMultiLineStringGeometry_.bind(_this),\n      'MultiPolygon': _this.segmentMultiPolygonGeometry_.bind(_this),\n      'GeometryCollection': _this.segmentGeometryCollectionGeometry_.bind(_this),\n      'Circle': _this.segmentCircleGeometry_.bind(_this)\n    };\n    return _this;\n  }\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n\n\n  Snap.prototype.addFeature = function (feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        var segments =\n        /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */\n        [];\n        segmenter(segments, geometry);\n\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0]\n          });\n        } else if (segments.length > 1) {\n          var extents = segments.map(function (s) {\n            return boundingExtent(s);\n          });\n          var segmentsData = segments.map(function (segment) {\n            return {\n              feature: feature,\n              segment: segment\n            };\n          });\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureAdd_ = function (feature) {\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureRemove_ = function (feature) {\n    this.removeFeature(feature);\n  };\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n\n\n  Snap.prototype.getFeatures_ = function () {\n    var features;\n\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n\n    return features;\n  };\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n\n\n  Snap.prototype.handleEvent = function (evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n\n    return _super.prototype.handleEvent.call(this, evt);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureAdd_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureRemove_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  };\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureChange_ = function (evt) {\n    var feature =\n    /** @type {import(\"../Feature.js\").default} */\n    evt.target;\n\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  Snap.prototype.handleUpEvent = function (evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n\n    return false;\n  };\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n\n\n  Snap.prototype.removeFeature = function (feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove_1 = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove_1.push(node);\n        }\n      });\n\n      for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove_1[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n\n\n  Snap.prototype.setMap = function (map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features =\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    this.getFeatures_();\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n\n    _super.prototype.setMap.call(this, map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n\n\n  Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box);\n    var segmentsLength = segments.length;\n\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    var projection = map.getView().getProjection();\n    var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n    var closestVertex;\n    var minSquaredDistance = Infinity;\n    var squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n\n    var getResult = function () {\n      if (closestVertex) {\n        var vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        var squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])]\n          };\n        }\n      }\n\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (var i = 0; i < segmentsLength; ++i) {\n        var segmentData = segments[i];\n\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach(function (vertex) {\n            var tempVertexCoord = fromUserCoordinate(vertex, projection);\n            var delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n\n      var result = getResult();\n\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (var i = 0; i < segmentsLength; ++i) {\n        var vertex = null;\n        var segmentData = segments[i];\n\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          var circleGeometry = segmentData.feature.getGeometry();\n          var userProjection = getUserProjection();\n\n          if (userProjection) {\n            circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n          }\n\n          vertex = toUserCoordinate(closestOnCircle(projectedCoordinate,\n          /** @type {import(\"../geom/Circle.js\").default} */\n          circleGeometry), projection);\n        } else {\n          var _a = segmentData.segment,\n              segmentStart = _a[0],\n              segmentEnd = _a[1]; // points have only one coordinate\n\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n\n        if (vertex) {\n          var delta = squaredDistance(projectedCoordinate, vertex);\n\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      var result = getResult();\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n\n\n  Snap.prototype.updateFeature_ = function (feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentCircleGeometry_ = function (segments, geometry) {\n    var projection = this.getMap().getView().getProjection();\n    var circleGeometry = geometry;\n    var userProjection = getUserProjection();\n\n    if (userProjection) {\n      circleGeometry =\n      /** @type {import(\"../geom/Circle.js\").default} */\n      circleGeometry.clone().transform(userProjection, projection);\n    }\n\n    var polygon = fromCircle(circleGeometry);\n\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n\n    var coordinates = polygon.getCoordinates()[0];\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentGeometryCollectionGeometry_ = function (segments, geometry) {\n    var geometries = geometry.getGeometriesArray();\n\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentLineStringGeometry_ = function (segments, geometry) {\n    var coordinates = geometry.getCoordinates();\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentMultiLineStringGeometry_ = function (segments, geometry) {\n    var lines = geometry.getCoordinates();\n\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentMultiPointGeometry_ = function (segments, geometry) {\n    geometry.getCoordinates().forEach(function (point) {\n      segments.push([point]);\n    });\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentMultiPolygonGeometry_ = function (segments, geometry) {\n    var polygons = geometry.getCoordinates();\n\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentPointGeometry_ = function (segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentPolygonGeometry_ = function (segments, geometry) {\n    var rings = geometry.getCoordinates();\n\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  };\n\n  return Snap;\n}(PointerInteraction);\n\nexport default Snap;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","CollectionEventType","EventType","PointerInteraction","RBush","VectorEventType","FALSE","TRUE","boundingExtent","createEmpty","closestOnCircle","closestOnSegment","squaredDistance","fromCircle","fromUserCoordinate","getUserProjection","toUserCoordinate","getUid","getValues","listen","unlistenByKey","getFeatureFromEvent","evt","feature","element","tempSegment","Snap","_super","opt_options","_this","options","pointerOptions","handleDownEvent","stopDown","source_","source","vertex_","vertex","undefined","edge_","edge","features_","features","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","pixelTolerance_","pixelTolerance","rBush_","GEOMETRY_SEGMENTERS_","segmentPointGeometry_","bind","segmentLineStringGeometry_","segmentPolygonGeometry_","segmentMultiPointGeometry_","segmentMultiLineStringGeometry_","segmentMultiPolygonGeometry_","segmentGeometryCollectionGeometry_","segmentCircleGeometry_","addFeature","opt_listen","register","feature_uid","geometry","getGeometry","segmenter","getType","getExtent","segments","length","insert","segment","extents","map","s","segmentsData","load","CHANGE","handleFeatureChange_","forEachFeatureAdd_","forEachFeatureRemove_","removeFeature","getFeatures_","getFeatures","handleEvent","result","snapTo","pixel","coordinate","slice","vertexPixel","handleFeatureAdd_","handleFeatureRemove_","target","handlingDownUpSequence","uid","updateFeature_","handleUpEvent","featuresToUpdate","forEach","opt_unlisten","unregister","extent","rBush","nodesToRemove_1","forEachInExtent","node","push","i","remove","setMap","currentMap","getMap","keys","ADD","REMOVE","ADDFEATURE","REMOVEFEATURE","pixelCoordinate","lowerLeft","getCoordinateFromPixel","upperRight","box","getInExtent","segmentsLength","projection","getView","getProjection","projectedCoordinate","closestVertex","minSquaredDistance","Infinity","squaredPixelTolerance","getResult","getPixelFromCoordinate","squaredPixelDistance","Math","round","segmentData","tempVertexCoord","delta","circleGeometry","userProjection","clone","transform","_a","segmentStart","segmentEnd","polygon","coordinates","getCoordinates","ii","geometries","getGeometriesArray","lines","j","jj","point","polygons","k","kk","rings"],"sources":["/home/asura/github/smartcity/source/node_modules/ol/interaction/Snap.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, squaredDistance, } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate, } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { getValues } from '../obj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n    if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature) {\n        return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n            .feature;\n    }\n    else if (\n    /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element) {\n        return /** @type {import(\"../Feature.js\").default} */ (\n        /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element);\n    }\n}\nvar tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nvar Snap = /** @class */ (function (_super) {\n    __extends(Snap, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function Snap(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n        if (!pointerOptions.handleDownEvent) {\n            pointerOptions.handleDownEvent = TRUE;\n        }\n        if (!pointerOptions.stopDown) {\n            pointerOptions.stopDown = FALSE;\n        }\n        _this = _super.call(this, pointerOptions) || this;\n        /**\n         * @type {import(\"../source/Vector.js\").default|null}\n         * @private\n         */\n        _this.source_ = options.source ? options.source : null;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.edge_ = options.edge !== undefined ? options.edge : true;\n        /**\n         * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n         * @private\n         */\n        _this.features_ = options.features ? options.features : null;\n        /**\n         * @type {Array<import(\"../events.js\").EventsKey>}\n         * @private\n         */\n        _this.featuresListenerKeys_ = [];\n        /**\n         * @type {Object<string, import(\"../events.js\").EventsKey>}\n         * @private\n         */\n        _this.featureChangeListenerKeys_ = {};\n        /**\n         * Extents are preserved so indexed segment can be quickly removed\n         * when its feature geometry changes\n         * @type {Object<string, import(\"../extent.js\").Extent>}\n         * @private\n         */\n        _this.indexedFeaturesExtents_ = {};\n        /**\n         * If a feature geometry changes while a pointer drag|move event occurs, the\n         * feature doesn't get updated right away.  It will be at the next 'pointerup'\n         * event fired.\n         * @type {!Object<string, import(\"../Feature.js\").default>}\n         * @private\n         */\n        _this.pendingFeatures_ = {};\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.pixelTolerance_ =\n            options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n        /**\n         * Segment RTree for each layer\n         * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n         * @private\n         */\n        _this.rBush_ = new RBush();\n        /**\n         * @const\n         * @private\n         * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n         */\n        _this.GEOMETRY_SEGMENTERS_ = {\n            'Point': _this.segmentPointGeometry_.bind(_this),\n            'LineString': _this.segmentLineStringGeometry_.bind(_this),\n            'LinearRing': _this.segmentLineStringGeometry_.bind(_this),\n            'Polygon': _this.segmentPolygonGeometry_.bind(_this),\n            'MultiPoint': _this.segmentMultiPointGeometry_.bind(_this),\n            'MultiLineString': _this.segmentMultiLineStringGeometry_.bind(_this),\n            'MultiPolygon': _this.segmentMultiPolygonGeometry_.bind(_this),\n            'GeometryCollection': _this.segmentGeometryCollectionGeometry_.bind(_this),\n            'Circle': _this.segmentCircleGeometry_.bind(_this),\n        };\n        return _this;\n    }\n    /**\n     * Add a feature to the collection of features that we may snap to.\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n     *     Defaults to `true`.\n     * @api\n     */\n    Snap.prototype.addFeature = function (feature, opt_listen) {\n        var register = opt_listen !== undefined ? opt_listen : true;\n        var feature_uid = getUid(feature);\n        var geometry = feature.getGeometry();\n        if (geometry) {\n            var segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n            if (segmenter) {\n                this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n                var segments = \n                /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n                segmenter(segments, geometry);\n                if (segments.length === 1) {\n                    this.rBush_.insert(boundingExtent(segments[0]), {\n                        feature: feature,\n                        segment: segments[0],\n                    });\n                }\n                else if (segments.length > 1) {\n                    var extents = segments.map(function (s) { return boundingExtent(s); });\n                    var segmentsData = segments.map(function (segment) { return ({\n                        feature: feature,\n                        segment: segment,\n                    }); });\n                    this.rBush_.load(extents, segmentsData);\n                }\n            }\n        }\n        if (register) {\n            this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n        }\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @private\n     */\n    Snap.prototype.forEachFeatureAdd_ = function (feature) {\n        this.addFeature(feature);\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @private\n     */\n    Snap.prototype.forEachFeatureRemove_ = function (feature) {\n        this.removeFeature(feature);\n    };\n    /**\n     * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n     * @private\n     */\n    Snap.prototype.getFeatures_ = function () {\n        var features;\n        if (this.features_) {\n            features = this.features_;\n        }\n        else if (this.source_) {\n            features = this.source_.getFeatures();\n        }\n        return features;\n    };\n    /**\n     * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     */\n    Snap.prototype.handleEvent = function (evt) {\n        var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n        if (result) {\n            evt.coordinate = result.vertex.slice(0, 2);\n            evt.pixel = result.vertexPixel;\n        }\n        return _super.prototype.handleEvent.call(this, evt);\n    };\n    /**\n     * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n     * @private\n     */\n    Snap.prototype.handleFeatureAdd_ = function (evt) {\n        var feature = getFeatureFromEvent(evt);\n        this.addFeature(feature);\n    };\n    /**\n     * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n     * @private\n     */\n    Snap.prototype.handleFeatureRemove_ = function (evt) {\n        var feature = getFeatureFromEvent(evt);\n        this.removeFeature(feature);\n    };\n    /**\n     * @param {import(\"../events/Event.js\").default} evt Event.\n     * @private\n     */\n    Snap.prototype.handleFeatureChange_ = function (evt) {\n        var feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n        if (this.handlingDownUpSequence) {\n            var uid = getUid(feature);\n            if (!(uid in this.pendingFeatures_)) {\n                this.pendingFeatures_[uid] = feature;\n            }\n        }\n        else {\n            this.updateFeature_(feature);\n        }\n    };\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Snap.prototype.handleUpEvent = function (evt) {\n        var featuresToUpdate = getValues(this.pendingFeatures_);\n        if (featuresToUpdate.length) {\n            featuresToUpdate.forEach(this.updateFeature_.bind(this));\n            this.pendingFeatures_ = {};\n        }\n        return false;\n    };\n    /**\n     * Remove a feature from the collection of features that we may snap to.\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n     *     or not. Defaults to `true`.\n     * @api\n     */\n    Snap.prototype.removeFeature = function (feature, opt_unlisten) {\n        var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n        var feature_uid = getUid(feature);\n        var extent = this.indexedFeaturesExtents_[feature_uid];\n        if (extent) {\n            var rBush = this.rBush_;\n            var nodesToRemove_1 = [];\n            rBush.forEachInExtent(extent, function (node) {\n                if (feature === node.feature) {\n                    nodesToRemove_1.push(node);\n                }\n            });\n            for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {\n                rBush.remove(nodesToRemove_1[i]);\n            }\n        }\n        if (unregister) {\n            unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n            delete this.featureChangeListenerKeys_[feature_uid];\n        }\n    };\n    /**\n     * Remove the interaction from its current map and attach it to the new map.\n     * Subclasses may set up event handlers to get notified about changes to\n     * the map here.\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     */\n    Snap.prototype.setMap = function (map) {\n        var currentMap = this.getMap();\n        var keys = this.featuresListenerKeys_;\n        var features = /** @type {Array<import(\"../Feature.js\").default>} */ (this.getFeatures_());\n        if (currentMap) {\n            keys.forEach(unlistenByKey);\n            keys.length = 0;\n            features.forEach(this.forEachFeatureRemove_.bind(this));\n        }\n        _super.prototype.setMap.call(this, map);\n        if (map) {\n            if (this.features_) {\n                keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n            }\n            else if (this.source_) {\n                keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n            }\n            features.forEach(this.forEachFeatureAdd_.bind(this));\n        }\n    };\n    /**\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n     * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     * @return {Result|null} Snap result\n     */\n    Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n        var lowerLeft = map.getCoordinateFromPixel([\n            pixel[0] - this.pixelTolerance_,\n            pixel[1] + this.pixelTolerance_,\n        ]);\n        var upperRight = map.getCoordinateFromPixel([\n            pixel[0] + this.pixelTolerance_,\n            pixel[1] - this.pixelTolerance_,\n        ]);\n        var box = boundingExtent([lowerLeft, upperRight]);\n        var segments = this.rBush_.getInExtent(box);\n        var segmentsLength = segments.length;\n        if (segmentsLength === 0) {\n            return null;\n        }\n        var projection = map.getView().getProjection();\n        var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n        var closestVertex;\n        var minSquaredDistance = Infinity;\n        var squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n        var getResult = function () {\n            if (closestVertex) {\n                var vertexPixel = map.getPixelFromCoordinate(closestVertex);\n                var squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n                if (squaredPixelDistance <= squaredPixelTolerance) {\n                    return {\n                        vertex: closestVertex,\n                        vertexPixel: [\n                            Math.round(vertexPixel[0]),\n                            Math.round(vertexPixel[1]),\n                        ],\n                    };\n                }\n            }\n            return null;\n        };\n        if (this.vertex_) {\n            for (var i = 0; i < segmentsLength; ++i) {\n                var segmentData = segments[i];\n                if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n                    segmentData.segment.forEach(function (vertex) {\n                        var tempVertexCoord = fromUserCoordinate(vertex, projection);\n                        var delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n                        if (delta < minSquaredDistance) {\n                            closestVertex = vertex;\n                            minSquaredDistance = delta;\n                        }\n                    });\n                }\n            }\n            var result = getResult();\n            if (result) {\n                return result;\n            }\n        }\n        if (this.edge_) {\n            for (var i = 0; i < segmentsLength; ++i) {\n                var vertex = null;\n                var segmentData = segments[i];\n                if (segmentData.feature.getGeometry().getType() === 'Circle') {\n                    var circleGeometry = segmentData.feature.getGeometry();\n                    var userProjection = getUserProjection();\n                    if (userProjection) {\n                        circleGeometry = circleGeometry\n                            .clone()\n                            .transform(userProjection, projection);\n                    }\n                    vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, \n                    /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)), projection);\n                }\n                else {\n                    var _a = segmentData.segment, segmentStart = _a[0], segmentEnd = _a[1];\n                    // points have only one coordinate\n                    if (segmentEnd) {\n                        tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n                        tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n                        vertex = closestOnSegment(projectedCoordinate, tempSegment);\n                    }\n                }\n                if (vertex) {\n                    var delta = squaredDistance(projectedCoordinate, vertex);\n                    if (delta < minSquaredDistance) {\n                        closestVertex = vertex;\n                        minSquaredDistance = delta;\n                    }\n                }\n            }\n            var result = getResult();\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @private\n     */\n    Snap.prototype.updateFeature_ = function (feature) {\n        this.removeFeature(feature, false);\n        this.addFeature(feature, false);\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentCircleGeometry_ = function (segments, geometry) {\n        var projection = this.getMap().getView().getProjection();\n        var circleGeometry = geometry;\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry.clone().transform(userProjection, projection));\n        }\n        var polygon = fromCircle(circleGeometry);\n        if (userProjection) {\n            polygon.transform(projection, userProjection);\n        }\n        var coordinates = polygon.getCoordinates()[0];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            segments.push(coordinates.slice(i, i + 2));\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentGeometryCollectionGeometry_ = function (segments, geometry) {\n        var geometries = geometry.getGeometriesArray();\n        for (var i = 0; i < geometries.length; ++i) {\n            var segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n            if (segmenter) {\n                segmenter(segments, geometries[i]);\n            }\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentLineStringGeometry_ = function (segments, geometry) {\n        var coordinates = geometry.getCoordinates();\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            segments.push(coordinates.slice(i, i + 2));\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentMultiLineStringGeometry_ = function (segments, geometry) {\n        var lines = geometry.getCoordinates();\n        for (var j = 0, jj = lines.length; j < jj; ++j) {\n            var coordinates = lines[j];\n            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n                segments.push(coordinates.slice(i, i + 2));\n            }\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentMultiPointGeometry_ = function (segments, geometry) {\n        geometry.getCoordinates().forEach(function (point) {\n            segments.push([point]);\n        });\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentMultiPolygonGeometry_ = function (segments, geometry) {\n        var polygons = geometry.getCoordinates();\n        for (var k = 0, kk = polygons.length; k < kk; ++k) {\n            var rings = polygons[k];\n            for (var j = 0, jj = rings.length; j < jj; ++j) {\n                var coordinates = rings[j];\n                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n                    segments.push(coordinates.slice(i, i + 2));\n                }\n            }\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentPointGeometry_ = function (segments, geometry) {\n        segments.push([geometry.getCoordinates()]);\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentPolygonGeometry_ = function (segments, geometry) {\n        var rings = geometry.getCoordinates();\n        for (var j = 0, jj = rings.length; j < jj; ++j) {\n            var coordinates = rings[j];\n            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n                segments.push(coordinates.slice(i, i + 2));\n            }\n        }\n    };\n    return Snap;\n}(PointerInteraction));\nexport default Snap;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}