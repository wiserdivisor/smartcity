{"ast":null,"code":"/**\n * @module ol/extent\n */\nimport Relationship from './extent/Relationship.js';\nimport { assert } from './asserts.js';\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n\n/**\n * Extent corner.\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\n */\n\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\n\nexport function boundingExtent(coordinates) {\n  var extent = createEmpty();\n\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n\n  return extent;\n}\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent} [opt_extent] Destination extent.\n * @private\n * @return {Extent} Extent.\n */\n\nfunction _boundingExtentXYs(xs, ys, opt_extent) {\n  var minX = Math.min.apply(null, xs);\n  var minY = Math.min.apply(null, ys);\n  var maxX = Math.max.apply(null, xs);\n  var maxY = Math.max.apply(null, ys);\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n}\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n * @api\n */\n\n\nexport function buffer(extent, value, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0] - value;\n    opt_extent[1] = extent[1] - value;\n    opt_extent[2] = extent[2] + value;\n    opt_extent[3] = extent[3] + value;\n    return opt_extent;\n  } else {\n    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];\n  }\n}\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} The clone.\n */\n\nexport function clone(extent, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0];\n    opt_extent[1] = extent[1];\n    opt_extent[2] = extent[2];\n    opt_extent[3] = extent[3];\n    return opt_extent;\n  } else {\n    return extent.slice();\n  }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\n\nexport function closestSquaredDistanceXY(extent, x, y) {\n  var dx, dy;\n\n  if (x < extent[0]) {\n    dx = extent[0] - x;\n  } else if (extent[2] < x) {\n    dx = x - extent[2];\n  } else {\n    dx = 0;\n  }\n\n  if (y < extent[1]) {\n    dy = extent[1] - y;\n  } else if (extent[3] < y) {\n    dy = y - extent[3];\n  } else {\n    dy = 0;\n  }\n\n  return dx * dx + dy * dy;\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\n\nexport function containsCoordinate(extent, coordinate) {\n  return containsXY(extent, coordinate[0], coordinate[1]);\n}\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\n\nexport function containsExtent(extent1, extent2) {\n  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\n\nexport function containsXY(extent, x, y) {\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */\n\nexport function coordinateRelationship(extent, coordinate) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var x = coordinate[0];\n  var y = coordinate[1];\n  var relationship = Relationship.UNKNOWN;\n\n  if (x < minX) {\n    relationship = relationship | Relationship.LEFT;\n  } else if (x > maxX) {\n    relationship = relationship | Relationship.RIGHT;\n  }\n\n  if (y < minY) {\n    relationship = relationship | Relationship.BELOW;\n  } else if (y > maxY) {\n    relationship = relationship | Relationship.ABOVE;\n  }\n\n  if (relationship === Relationship.UNKNOWN) {\n    relationship = Relationship.INTERSECTING;\n  }\n\n  return relationship;\n}\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\n\nexport function createEmpty() {\n  return [Infinity, Infinity, -Infinity, -Infinity];\n}\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent} [opt_extent] Destination extent.\n * @return {Extent} Extent.\n */\n\nexport function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = minX;\n    opt_extent[1] = minY;\n    opt_extent[2] = maxX;\n    opt_extent[3] = maxY;\n    return opt_extent;\n  } else {\n    return [minX, minY, maxX, maxY];\n  }\n}\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\n\nexport function createOrUpdateEmpty(opt_extent) {\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\n\nexport function createOrUpdateFromCoordinate(coordinate, opt_extent) {\n  var x = coordinate[0];\n  var y = coordinate[1];\n  return createOrUpdate(x, y, x, y, opt_extent);\n}\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\n\nexport function createOrUpdateFromCoordinates(coordinates, opt_extent) {\n  var extent = createOrUpdateEmpty(opt_extent);\n  return extendCoordinates(extent, coordinates);\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\n\nexport function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {\n  var extent = createOrUpdateEmpty(opt_extent);\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\n\nexport function createOrUpdateFromRings(rings, opt_extent) {\n  var extent = createOrUpdateEmpty(opt_extent);\n  return extendRings(extent, rings);\n}\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\n\nexport function equals(extent1, extent2) {\n  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];\n}\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */\n\nexport function approximatelyEquals(extent1, extent2, tolerance) {\n  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;\n}\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\n\nexport function extend(extent1, extent2) {\n  if (extent2[0] < extent1[0]) {\n    extent1[0] = extent2[0];\n  }\n\n  if (extent2[2] > extent1[2]) {\n    extent1[2] = extent2[2];\n  }\n\n  if (extent2[1] < extent1[1]) {\n    extent1[1] = extent2[1];\n  }\n\n  if (extent2[3] > extent1[3]) {\n    extent1[3] = extent2[3];\n  }\n\n  return extent1;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */\n\nexport function extendCoordinate(extent, coordinate) {\n  if (coordinate[0] < extent[0]) {\n    extent[0] = coordinate[0];\n  }\n\n  if (coordinate[0] > extent[2]) {\n    extent[2] = coordinate[0];\n  }\n\n  if (coordinate[1] < extent[1]) {\n    extent[1] = coordinate[1];\n  }\n\n  if (coordinate[1] > extent[3]) {\n    extent[3] = coordinate[1];\n  }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\n\nexport function extendCoordinates(extent, coordinates) {\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n\n  return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\n\nexport function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {\n  for (; offset < end; offset += stride) {\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n  }\n\n  return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\n\nexport function extendRings(extent, rings) {\n  for (var i = 0, ii = rings.length; i < ii; ++i) {\n    extendCoordinates(extent, rings[i]);\n  }\n\n  return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\n\nexport function extendXY(extent, x, y) {\n  extent[0] = Math.min(extent[0], x);\n  extent[1] = Math.min(extent[1], y);\n  extent[2] = Math.max(extent[2], x);\n  extent[3] = Math.max(extent[3], y);\n}\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */\n\nexport function forEachCorner(extent, callback) {\n  var val;\n  val = callback(getBottomLeft(extent));\n\n  if (val) {\n    return val;\n  }\n\n  val = callback(getBottomRight(extent));\n\n  if (val) {\n    return val;\n  }\n\n  val = callback(getTopRight(extent));\n\n  if (val) {\n    return val;\n  }\n\n  val = callback(getTopLeft(extent));\n\n  if (val) {\n    return val;\n  }\n\n  return false;\n}\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\n\nexport function getArea(extent) {\n  var area = 0;\n\n  if (!isEmpty(extent)) {\n    area = getWidth(extent) * getHeight(extent);\n  }\n\n  return area;\n}\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */\n\nexport function getBottomLeft(extent) {\n  return [extent[0], extent[1]];\n}\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */\n\nexport function getBottomRight(extent) {\n  return [extent[2], extent[1]];\n}\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */\n\nexport function getCenter(extent) {\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {Corner} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */\n\nexport function getCorner(extent, corner) {\n  var coordinate;\n\n  if (corner === 'bottom-left') {\n    coordinate = getBottomLeft(extent);\n  } else if (corner === 'bottom-right') {\n    coordinate = getBottomRight(extent);\n  } else if (corner === 'top-left') {\n    coordinate = getTopLeft(extent);\n  } else if (corner === 'top-right') {\n    coordinate = getTopRight(extent);\n  } else {\n    assert(false, 13); // Invalid corner\n  }\n\n  return coordinate;\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\n\nexport function getEnlargedArea(extent1, extent2) {\n  var minX = Math.min(extent1[0], extent2[0]);\n  var minY = Math.min(extent1[1], extent2[1]);\n  var maxX = Math.max(extent1[2], extent2[2]);\n  var maxY = Math.max(extent1[3], extent2[3]);\n  return (maxX - minX) * (maxY - minY);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent} [opt_extent] Destination extent.\n * @return {Extent} Extent.\n */\n\nexport function getForViewAndSize(center, resolution, rotation, size, opt_extent) {\n  var _a = getRotatedViewport(center, resolution, rotation, size),\n      x0 = _a[0],\n      y0 = _a[1],\n      x1 = _a[2],\n      y1 = _a[3],\n      x2 = _a[4],\n      y2 = _a[5],\n      x3 = _a[6],\n      y3 = _a[7];\n\n  return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @return {Array<number>} Linear ring representing the viewport.\n */\n\nexport function getRotatedViewport(center, resolution, rotation, size) {\n  var dx = resolution * size[0] / 2;\n  var dy = resolution * size[1] / 2;\n  var cosRotation = Math.cos(rotation);\n  var sinRotation = Math.sin(rotation);\n  var xCos = dx * cosRotation;\n  var xSin = dx * sinRotation;\n  var yCos = dy * cosRotation;\n  var ySin = dy * sinRotation;\n  var x = center[0];\n  var y = center[1];\n  return [x - xCos + ySin, y - xSin - yCos, x - xCos - ySin, y - xSin + yCos, x + xCos - ySin, y + xSin + yCos, x + xCos + ySin, y + xSin - yCos, x - xCos + ySin, y - xSin - yCos];\n}\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\n\nexport function getHeight(extent) {\n  return extent[3] - extent[1];\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\n\nexport function getIntersectionArea(extent1, extent2) {\n  var intersection = getIntersection(extent1, extent2);\n  return getArea(intersection);\n}\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent} [opt_extent] Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\n\nexport function getIntersection(extent1, extent2, opt_extent) {\n  var intersection = opt_extent ? opt_extent : createEmpty();\n\n  if (intersects(extent1, extent2)) {\n    if (extent1[0] > extent2[0]) {\n      intersection[0] = extent1[0];\n    } else {\n      intersection[0] = extent2[0];\n    }\n\n    if (extent1[1] > extent2[1]) {\n      intersection[1] = extent1[1];\n    } else {\n      intersection[1] = extent2[1];\n    }\n\n    if (extent1[2] < extent2[2]) {\n      intersection[2] = extent1[2];\n    } else {\n      intersection[2] = extent2[2];\n    }\n\n    if (extent1[3] < extent2[3]) {\n      intersection[3] = extent1[3];\n    } else {\n      intersection[3] = extent2[3];\n    }\n  } else {\n    createOrUpdateEmpty(intersection);\n  }\n\n  return intersection;\n}\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\n\nexport function getMargin(extent) {\n  return getWidth(extent) + getHeight(extent);\n}\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */\n\nexport function getSize(extent) {\n  return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */\n\nexport function getTopLeft(extent) {\n  return [extent[0], extent[3]];\n}\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */\n\nexport function getTopRight(extent) {\n  return [extent[2], extent[3]];\n}\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\n\nexport function getWidth(extent) {\n  return extent[2] - extent[0];\n}\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\n\nexport function intersects(extent1, extent2) {\n  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];\n}\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\n\nexport function isEmpty(extent) {\n  return extent[2] < extent[0] || extent[3] < extent[1];\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\n\nexport function returnOrUpdate(extent, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0];\n    opt_extent[1] = extent[1];\n    opt_extent[2] = extent[2];\n    opt_extent[3] = extent[3];\n    return opt_extent;\n  } else {\n    return extent;\n  }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\n\nexport function scaleFromCenter(extent, value) {\n  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);\n  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);\n  extent[0] -= deltaX;\n  extent[2] += deltaX;\n  extent[1] -= deltaY;\n  extent[3] += deltaY;\n}\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\n\nexport function intersectsSegment(extent, start, end) {\n  var intersects = false;\n  var startRel = coordinateRelationship(extent, start);\n  var endRel = coordinateRelationship(extent, end);\n\n  if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {\n    intersects = true;\n  } else {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var startX = start[0];\n    var startY = start[1];\n    var endX = end[0];\n    var endY = end[1];\n    var slope = (endY - startY) / (endX - startX);\n    var x = void 0,\n        y = void 0;\n\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n      // potentially intersects top\n      x = endX - (endY - maxY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n\n    if (!intersects && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {\n      // potentially intersects right\n      y = endY - (endX - maxX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n\n    if (!intersects && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {\n      // potentially intersects bottom\n      x = endX - (endY - minY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n\n    if (!intersects && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {\n      // potentially intersects left\n      y = endY - (endX - minX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n  }\n\n  return intersects;\n}\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent} [opt_extent] Destination extent.\n * @param {number} [opt_stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */\n\nexport function applyTransform(extent, transformFn, opt_extent, opt_stops) {\n  var coordinates = [];\n\n  if (opt_stops > 1) {\n    var width = extent[2] - extent[0];\n    var height = extent[3] - extent[1];\n\n    for (var i = 0; i < opt_stops; ++i) {\n      coordinates.push(extent[0] + width * i / opt_stops, extent[1], extent[2], extent[1] + height * i / opt_stops, extent[2] - width * i / opt_stops, extent[3], extent[0], extent[3] - height * i / opt_stops);\n    }\n  } else {\n    coordinates = [extent[0], extent[1], extent[2], extent[1], extent[2], extent[3], extent[0], extent[3]];\n  }\n\n  transformFn(coordinates, coordinates, 2);\n  var xs = [];\n  var ys = [];\n\n  for (var i = 0, l = coordinates.length; i < l; i += 2) {\n    xs.push(coordinates[i]);\n    ys.push(coordinates[i + 1]);\n  }\n\n  return _boundingExtentXYs(xs, ys, opt_extent);\n}\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */\n\nexport function wrapX(extent, projection) {\n  var projectionExtent = projection.getExtent();\n  var center = getCenter(extent);\n\n  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {\n    var worldWidth = getWidth(projectionExtent);\n    var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);\n    var offset = worldsAway * worldWidth;\n    extent[0] -= offset;\n    extent[2] -= offset;\n  }\n\n  return extent;\n}\n/**\n * Fits the extent to the real world\n *\n * If the extent does not cross the anti meridian, this will return the extent in an array\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\n * real world\n *\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Array<Extent>} The extent within the real world extent.\n */\n\nexport function wrapAndSliceX(extent, projection) {\n  if (projection.canWrapX()) {\n    var projectionExtent = projection.getExtent();\n\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    }\n\n    wrapX(extent, projection);\n    var worldWidth = getWidth(projectionExtent);\n\n    if (getWidth(extent) > worldWidth) {\n      // the extent wraps around on itself\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    } else if (extent[0] < projectionExtent[0]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [[extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]], [projectionExtent[0], extent[1], extent[2], extent[3]]];\n    } else if (extent[2] > projectionExtent[2]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [[extent[0], extent[1], projectionExtent[2], extent[3]], [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]];\n    }\n  }\n\n  return [extent];\n}","map":{"version":3,"names":["Relationship","assert","boundingExtent","coordinates","extent","createEmpty","i","ii","length","extendCoordinate","_boundingExtentXYs","xs","ys","opt_extent","minX","Math","min","apply","minY","maxX","max","maxY","createOrUpdate","buffer","value","clone","slice","closestSquaredDistanceXY","x","y","dx","dy","containsCoordinate","coordinate","containsXY","containsExtent","extent1","extent2","coordinateRelationship","relationship","UNKNOWN","LEFT","RIGHT","BELOW","ABOVE","INTERSECTING","Infinity","createOrUpdateEmpty","createOrUpdateFromCoordinate","createOrUpdateFromCoordinates","extendCoordinates","createOrUpdateFromFlatCoordinates","flatCoordinates","offset","end","stride","extendFlatCoordinates","createOrUpdateFromRings","rings","extendRings","equals","approximatelyEquals","tolerance","abs","extend","extendXY","forEachCorner","callback","val","getBottomLeft","getBottomRight","getTopRight","getTopLeft","getArea","area","isEmpty","getWidth","getHeight","getCenter","getCorner","corner","getEnlargedArea","getForViewAndSize","center","resolution","rotation","size","_a","getRotatedViewport","x0","y0","x1","y1","x2","y2","x3","y3","cosRotation","cos","sinRotation","sin","xCos","xSin","yCos","ySin","getIntersectionArea","intersection","getIntersection","intersects","getMargin","getSize","returnOrUpdate","scaleFromCenter","deltaX","deltaY","intersectsSegment","start","startRel","endRel","startX","startY","endX","endY","slope","applyTransform","transformFn","opt_stops","width","height","push","l","wrapX","projection","projectionExtent","getExtent","canWrapX","worldWidth","worldsAway","floor","wrapAndSliceX","isFinite"],"sources":["/home/asura/github/smartcity/source/node_modules/ol/extent.js"],"sourcesContent":["/**\n * @module ol/extent\n */\nimport Relationship from './extent/Relationship.js';\nimport { assert } from './asserts.js';\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n/**\n * Extent corner.\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\n */\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\nexport function boundingExtent(coordinates) {\n    var extent = createEmpty();\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        extendCoordinate(extent, coordinates[i]);\n    }\n    return extent;\n}\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent} [opt_extent] Destination extent.\n * @private\n * @return {Extent} Extent.\n */\nfunction _boundingExtentXYs(xs, ys, opt_extent) {\n    var minX = Math.min.apply(null, xs);\n    var minY = Math.min.apply(null, ys);\n    var maxX = Math.max.apply(null, xs);\n    var maxY = Math.max.apply(null, ys);\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n}\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n * @api\n */\nexport function buffer(extent, value, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = extent[0] - value;\n        opt_extent[1] = extent[1] - value;\n        opt_extent[2] = extent[2] + value;\n        opt_extent[3] = extent[3] + value;\n        return opt_extent;\n    }\n    else {\n        return [\n            extent[0] - value,\n            extent[1] - value,\n            extent[2] + value,\n            extent[3] + value,\n        ];\n    }\n}\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} The clone.\n */\nexport function clone(extent, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = extent[0];\n        opt_extent[1] = extent[1];\n        opt_extent[2] = extent[2];\n        opt_extent[3] = extent[3];\n        return opt_extent;\n    }\n    else {\n        return extent.slice();\n    }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\nexport function closestSquaredDistanceXY(extent, x, y) {\n    var dx, dy;\n    if (x < extent[0]) {\n        dx = extent[0] - x;\n    }\n    else if (extent[2] < x) {\n        dx = x - extent[2];\n    }\n    else {\n        dx = 0;\n    }\n    if (y < extent[1]) {\n        dy = extent[1] - y;\n    }\n    else if (extent[3] < y) {\n        dy = y - extent[3];\n    }\n    else {\n        dy = 0;\n    }\n    return dx * dx + dy * dy;\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\nexport function containsCoordinate(extent, coordinate) {\n    return containsXY(extent, coordinate[0], coordinate[1]);\n}\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\nexport function containsExtent(extent1, extent2) {\n    return (extent1[0] <= extent2[0] &&\n        extent2[2] <= extent1[2] &&\n        extent1[1] <= extent2[1] &&\n        extent2[3] <= extent1[3]);\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\nexport function containsXY(extent, x, y) {\n    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */\nexport function coordinateRelationship(extent, coordinate) {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var x = coordinate[0];\n    var y = coordinate[1];\n    var relationship = Relationship.UNKNOWN;\n    if (x < minX) {\n        relationship = relationship | Relationship.LEFT;\n    }\n    else if (x > maxX) {\n        relationship = relationship | Relationship.RIGHT;\n    }\n    if (y < minY) {\n        relationship = relationship | Relationship.BELOW;\n    }\n    else if (y > maxY) {\n        relationship = relationship | Relationship.ABOVE;\n    }\n    if (relationship === Relationship.UNKNOWN) {\n        relationship = Relationship.INTERSECTING;\n    }\n    return relationship;\n}\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\nexport function createEmpty() {\n    return [Infinity, Infinity, -Infinity, -Infinity];\n}\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent} [opt_extent] Destination extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = minX;\n        opt_extent[1] = minY;\n        opt_extent[2] = maxX;\n        opt_extent[3] = maxY;\n        return opt_extent;\n    }\n    else {\n        return [minX, minY, maxX, maxY];\n    }\n}\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateEmpty(opt_extent) {\n    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinate(coordinate, opt_extent) {\n    var x = coordinate[0];\n    var y = coordinate[1];\n    return createOrUpdate(x, y, x, y, opt_extent);\n}\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinates(coordinates, opt_extent) {\n    var extent = createOrUpdateEmpty(opt_extent);\n    return extendCoordinates(extent, coordinates);\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {\n    var extent = createOrUpdateEmpty(opt_extent);\n    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromRings(rings, opt_extent) {\n    var extent = createOrUpdateEmpty(opt_extent);\n    return extendRings(extent, rings);\n}\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\nexport function equals(extent1, extent2) {\n    return (extent1[0] == extent2[0] &&\n        extent1[2] == extent2[2] &&\n        extent1[1] == extent2[1] &&\n        extent1[3] == extent2[3]);\n}\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */\nexport function approximatelyEquals(extent1, extent2, tolerance) {\n    return (Math.abs(extent1[0] - extent2[0]) < tolerance &&\n        Math.abs(extent1[2] - extent2[2]) < tolerance &&\n        Math.abs(extent1[1] - extent2[1]) < tolerance &&\n        Math.abs(extent1[3] - extent2[3]) < tolerance);\n}\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\nexport function extend(extent1, extent2) {\n    if (extent2[0] < extent1[0]) {\n        extent1[0] = extent2[0];\n    }\n    if (extent2[2] > extent1[2]) {\n        extent1[2] = extent2[2];\n    }\n    if (extent2[1] < extent1[1]) {\n        extent1[1] = extent2[1];\n    }\n    if (extent2[3] > extent1[3]) {\n        extent1[3] = extent2[3];\n    }\n    return extent1;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */\nexport function extendCoordinate(extent, coordinate) {\n    if (coordinate[0] < extent[0]) {\n        extent[0] = coordinate[0];\n    }\n    if (coordinate[0] > extent[2]) {\n        extent[2] = coordinate[0];\n    }\n    if (coordinate[1] < extent[1]) {\n        extent[1] = coordinate[1];\n    }\n    if (coordinate[1] > extent[3]) {\n        extent[3] = coordinate[1];\n    }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\nexport function extendCoordinates(extent, coordinates) {\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        extendCoordinate(extent, coordinates[i]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\nexport function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {\n    for (; offset < end; offset += stride) {\n        extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\nexport function extendRings(extent, rings) {\n    for (var i = 0, ii = rings.length; i < ii; ++i) {\n        extendCoordinates(extent, rings[i]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\nexport function extendXY(extent, x, y) {\n    extent[0] = Math.min(extent[0], x);\n    extent[1] = Math.min(extent[1], y);\n    extent[2] = Math.max(extent[2], x);\n    extent[3] = Math.max(extent[3], y);\n}\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */\nexport function forEachCorner(extent, callback) {\n    var val;\n    val = callback(getBottomLeft(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getBottomRight(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getTopRight(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getTopLeft(extent));\n    if (val) {\n        return val;\n    }\n    return false;\n}\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\nexport function getArea(extent) {\n    var area = 0;\n    if (!isEmpty(extent)) {\n        area = getWidth(extent) * getHeight(extent);\n    }\n    return area;\n}\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */\nexport function getBottomLeft(extent) {\n    return [extent[0], extent[1]];\n}\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */\nexport function getBottomRight(extent) {\n    return [extent[2], extent[1]];\n}\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */\nexport function getCenter(extent) {\n    return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {Corner} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */\nexport function getCorner(extent, corner) {\n    var coordinate;\n    if (corner === 'bottom-left') {\n        coordinate = getBottomLeft(extent);\n    }\n    else if (corner === 'bottom-right') {\n        coordinate = getBottomRight(extent);\n    }\n    else if (corner === 'top-left') {\n        coordinate = getTopLeft(extent);\n    }\n    else if (corner === 'top-right') {\n        coordinate = getTopRight(extent);\n    }\n    else {\n        assert(false, 13); // Invalid corner\n    }\n    return coordinate;\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\nexport function getEnlargedArea(extent1, extent2) {\n    var minX = Math.min(extent1[0], extent2[0]);\n    var minY = Math.min(extent1[1], extent2[1]);\n    var maxX = Math.max(extent1[2], extent2[2]);\n    var maxY = Math.max(extent1[3], extent2[3]);\n    return (maxX - minX) * (maxY - minY);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent} [opt_extent] Destination extent.\n * @return {Extent} Extent.\n */\nexport function getForViewAndSize(center, resolution, rotation, size, opt_extent) {\n    var _a = getRotatedViewport(center, resolution, rotation, size), x0 = _a[0], y0 = _a[1], x1 = _a[2], y1 = _a[3], x2 = _a[4], y2 = _a[5], x3 = _a[6], y3 = _a[7];\n    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @return {Array<number>} Linear ring representing the viewport.\n */\nexport function getRotatedViewport(center, resolution, rotation, size) {\n    var dx = (resolution * size[0]) / 2;\n    var dy = (resolution * size[1]) / 2;\n    var cosRotation = Math.cos(rotation);\n    var sinRotation = Math.sin(rotation);\n    var xCos = dx * cosRotation;\n    var xSin = dx * sinRotation;\n    var yCos = dy * cosRotation;\n    var ySin = dy * sinRotation;\n    var x = center[0];\n    var y = center[1];\n    return [\n        x - xCos + ySin,\n        y - xSin - yCos,\n        x - xCos - ySin,\n        y - xSin + yCos,\n        x + xCos - ySin,\n        y + xSin + yCos,\n        x + xCos + ySin,\n        y + xSin - yCos,\n        x - xCos + ySin,\n        y - xSin - yCos,\n    ];\n}\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\nexport function getHeight(extent) {\n    return extent[3] - extent[1];\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\nexport function getIntersectionArea(extent1, extent2) {\n    var intersection = getIntersection(extent1, extent2);\n    return getArea(intersection);\n}\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent} [opt_extent] Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\nexport function getIntersection(extent1, extent2, opt_extent) {\n    var intersection = opt_extent ? opt_extent : createEmpty();\n    if (intersects(extent1, extent2)) {\n        if (extent1[0] > extent2[0]) {\n            intersection[0] = extent1[0];\n        }\n        else {\n            intersection[0] = extent2[0];\n        }\n        if (extent1[1] > extent2[1]) {\n            intersection[1] = extent1[1];\n        }\n        else {\n            intersection[1] = extent2[1];\n        }\n        if (extent1[2] < extent2[2]) {\n            intersection[2] = extent1[2];\n        }\n        else {\n            intersection[2] = extent2[2];\n        }\n        if (extent1[3] < extent2[3]) {\n            intersection[3] = extent1[3];\n        }\n        else {\n            intersection[3] = extent2[3];\n        }\n    }\n    else {\n        createOrUpdateEmpty(intersection);\n    }\n    return intersection;\n}\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\nexport function getMargin(extent) {\n    return getWidth(extent) + getHeight(extent);\n}\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */\nexport function getSize(extent) {\n    return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */\nexport function getTopLeft(extent) {\n    return [extent[0], extent[3]];\n}\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */\nexport function getTopRight(extent) {\n    return [extent[2], extent[3]];\n}\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\nexport function getWidth(extent) {\n    return extent[2] - extent[0];\n}\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\nexport function intersects(extent1, extent2) {\n    return (extent1[0] <= extent2[2] &&\n        extent1[2] >= extent2[0] &&\n        extent1[1] <= extent2[3] &&\n        extent1[3] >= extent2[1]);\n}\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\nexport function isEmpty(extent) {\n    return extent[2] < extent[0] || extent[3] < extent[1];\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function returnOrUpdate(extent, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = extent[0];\n        opt_extent[1] = extent[1];\n        opt_extent[2] = extent[2];\n        opt_extent[3] = extent[3];\n        return opt_extent;\n    }\n    else {\n        return extent;\n    }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\nexport function scaleFromCenter(extent, value) {\n    var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\n    var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\n    extent[0] -= deltaX;\n    extent[2] += deltaX;\n    extent[1] -= deltaY;\n    extent[3] += deltaY;\n}\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\nexport function intersectsSegment(extent, start, end) {\n    var intersects = false;\n    var startRel = coordinateRelationship(extent, start);\n    var endRel = coordinateRelationship(extent, end);\n    if (startRel === Relationship.INTERSECTING ||\n        endRel === Relationship.INTERSECTING) {\n        intersects = true;\n    }\n    else {\n        var minX = extent[0];\n        var minY = extent[1];\n        var maxX = extent[2];\n        var maxY = extent[3];\n        var startX = start[0];\n        var startY = start[1];\n        var endX = end[0];\n        var endY = end[1];\n        var slope = (endY - startY) / (endX - startX);\n        var x = void 0, y = void 0;\n        if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n            // potentially intersects top\n            x = endX - (endY - maxY) / slope;\n            intersects = x >= minX && x <= maxX;\n        }\n        if (!intersects &&\n            !!(endRel & Relationship.RIGHT) &&\n            !(startRel & Relationship.RIGHT)) {\n            // potentially intersects right\n            y = endY - (endX - maxX) * slope;\n            intersects = y >= minY && y <= maxY;\n        }\n        if (!intersects &&\n            !!(endRel & Relationship.BELOW) &&\n            !(startRel & Relationship.BELOW)) {\n            // potentially intersects bottom\n            x = endX - (endY - minY) / slope;\n            intersects = x >= minX && x <= maxX;\n        }\n        if (!intersects &&\n            !!(endRel & Relationship.LEFT) &&\n            !(startRel & Relationship.LEFT)) {\n            // potentially intersects left\n            y = endY - (endX - minX) * slope;\n            intersects = y >= minY && y <= maxY;\n        }\n    }\n    return intersects;\n}\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent} [opt_extent] Destination extent.\n * @param {number} [opt_stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */\nexport function applyTransform(extent, transformFn, opt_extent, opt_stops) {\n    var coordinates = [];\n    if (opt_stops > 1) {\n        var width = extent[2] - extent[0];\n        var height = extent[3] - extent[1];\n        for (var i = 0; i < opt_stops; ++i) {\n            coordinates.push(extent[0] + (width * i) / opt_stops, extent[1], extent[2], extent[1] + (height * i) / opt_stops, extent[2] - (width * i) / opt_stops, extent[3], extent[0], extent[3] - (height * i) / opt_stops);\n        }\n    }\n    else {\n        coordinates = [\n            extent[0],\n            extent[1],\n            extent[2],\n            extent[1],\n            extent[2],\n            extent[3],\n            extent[0],\n            extent[3],\n        ];\n    }\n    transformFn(coordinates, coordinates, 2);\n    var xs = [];\n    var ys = [];\n    for (var i = 0, l = coordinates.length; i < l; i += 2) {\n        xs.push(coordinates[i]);\n        ys.push(coordinates[i + 1]);\n    }\n    return _boundingExtentXYs(xs, ys, opt_extent);\n}\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */\nexport function wrapX(extent, projection) {\n    var projectionExtent = projection.getExtent();\n    var center = getCenter(extent);\n    if (projection.canWrapX() &&\n        (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {\n        var worldWidth = getWidth(projectionExtent);\n        var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);\n        var offset = worldsAway * worldWidth;\n        extent[0] -= offset;\n        extent[2] -= offset;\n    }\n    return extent;\n}\n/**\n * Fits the extent to the real world\n *\n * If the extent does not cross the anti meridian, this will return the extent in an array\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\n * real world\n *\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Array<Extent>} The extent within the real world extent.\n */\nexport function wrapAndSliceX(extent, projection) {\n    if (projection.canWrapX()) {\n        var projectionExtent = projection.getExtent();\n        if (!isFinite(extent[0]) || !isFinite(extent[2])) {\n            return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n        }\n        wrapX(extent, projection);\n        var worldWidth = getWidth(projectionExtent);\n        if (getWidth(extent) > worldWidth) {\n            // the extent wraps around on itself\n            return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n        }\n        else if (extent[0] < projectionExtent[0]) {\n            // the extent crosses the anti meridian, so it needs to be sliced\n            return [\n                [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],\n                [projectionExtent[0], extent[1], extent[2], extent[3]],\n            ];\n        }\n        else if (extent[2] > projectionExtent[2]) {\n            // the extent crosses the anti meridian, so it needs to be sliced\n            return [\n                [extent[0], extent[1], projectionExtent[2], extent[3]],\n                [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],\n            ];\n        }\n    }\n    return [extent];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}