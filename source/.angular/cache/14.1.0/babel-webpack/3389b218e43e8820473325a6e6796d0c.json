{"ast":null,"code":"/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\n\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n  var edge = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return edge === 0 ? undefined : edge > 0;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n\n    if (i === 0) {\n      if (right && isClockwise || !right && !isClockwise) {\n        return false;\n      }\n    } else {\n      if (right && !isClockwise || !right && isClockwise) {\n        return false;\n      }\n    }\n\n    offset = end;\n  }\n\n  return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {\n      return false;\n    }\n\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n\n  return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;\n\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n\n    offset = end;\n  }\n\n  return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n\n  return offset;\n}\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to contruct a MultiPolygon\n */\n\nexport function inflateEnds(flatCoordinates, ends) {\n  var endss = [];\n  var offset = 0;\n  var prevEndIndex = 0;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i]; // classifies an array of rings into polygons with outer rings and holes\n\n    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n      endss.push(ends.slice(prevEndIndex, i + 1));\n    } else {\n      if (endss.length === 0) {\n        continue;\n      }\n\n      endss[endss.length - 1].push(ends[prevEndIndex]);\n    }\n\n    prevEndIndex = i + 1;\n    offset = end;\n  }\n\n  return endss;\n}","map":{"version":3,"names":["coordinates","reverseCoordinates","linearRingIsClockwise","flatCoordinates","offset","end","stride","edge","x1","y1","x2","y2","undefined","linearRingsAreOriented","ends","opt_right","right","i","ii","length","isClockwise","linearRingssAreOriented","endss","orientLinearRings","reverse","orientLinearRingsArray","inflateEnds","prevEndIndex","push","slice"],"sources":["/home/asura/github/smartcity/source/node_modules/ol/geom/flat/orient.js"],"sourcesContent":["/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n    // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n    // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n    var edge = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        edge += (x2 - x1) * (y2 + y1);\n        x1 = x2;\n        y1 = y2;\n    }\n    return edge === 0 ? undefined : edge > 0;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        if (i === 0) {\n            if ((right && isClockwise) || (!right && !isClockwise)) {\n                return false;\n            }\n        }\n        else {\n            if ((right && !isClockwise) || (!right && isClockwise)) {\n                return false;\n            }\n        }\n        offset = end;\n    }\n    return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {\n            return false;\n        }\n        if (ends.length) {\n            offset = ends[ends.length - 1];\n        }\n    }\n    return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        var reverse = i === 0\n            ? (right && isClockwise) || (!right && !isClockwise)\n            : (right && !isClockwise) || (!right && isClockwise);\n        if (reverse) {\n            reverseCoordinates(flatCoordinates, offset, end, stride);\n        }\n        offset = end;\n    }\n    return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n    }\n    return offset;\n}\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to contruct a MultiPolygon\n */\nexport function inflateEnds(flatCoordinates, ends) {\n    var endss = [];\n    var offset = 0;\n    var prevEndIndex = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        // classifies an array of rings into polygons with outer rings and holes\n        if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n            endss.push(ends.slice(prevEndIndex, i + 1));\n        }\n        else {\n            if (endss.length === 0) {\n                continue;\n            }\n            endss[endss.length - 1].push(ends[prevEndIndex]);\n        }\n        prevEndIndex = i + 1;\n        offset = end;\n    }\n    return endss;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,WAAW,IAAIC,kBAAxB,QAAkD,cAAlD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,qBAAT,CAA+BC,eAA/B,EAAgDC,MAAhD,EAAwDC,GAAxD,EAA6DC,MAA7D,EAAqE;EACxE;EACA;EACA,IAAIC,IAAI,GAAG,CAAX;EACA,IAAIC,EAAE,GAAGL,eAAe,CAACE,GAAG,GAAGC,MAAP,CAAxB;EACA,IAAIG,EAAE,GAAGN,eAAe,CAACE,GAAG,GAAGC,MAAN,GAAe,CAAhB,CAAxB;;EACA,OAAOF,MAAM,GAAGC,GAAhB,EAAqBD,MAAM,IAAIE,MAA/B,EAAuC;IACnC,IAAII,EAAE,GAAGP,eAAe,CAACC,MAAD,CAAxB;IACA,IAAIO,EAAE,GAAGR,eAAe,CAACC,MAAM,GAAG,CAAV,CAAxB;IACAG,IAAI,IAAI,CAACG,EAAE,GAAGF,EAAN,KAAaG,EAAE,GAAGF,EAAlB,CAAR;IACAD,EAAE,GAAGE,EAAL;IACAD,EAAE,GAAGE,EAAL;EACH;;EACD,OAAOJ,IAAI,KAAK,CAAT,GAAaK,SAAb,GAAyBL,IAAI,GAAG,CAAvC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,sBAAT,CAAgCV,eAAhC,EAAiDC,MAAjD,EAAyDU,IAAzD,EAA+DR,MAA/D,EAAuES,SAAvE,EAAkF;EACrF,IAAIC,KAAK,GAAGD,SAAS,KAAKH,SAAd,GAA0BG,SAA1B,GAAsC,KAAlD;;EACA,KAAK,IAAIE,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,IAAI,CAACK,MAA1B,EAAkCF,CAAC,GAAGC,EAAtC,EAA0C,EAAED,CAA5C,EAA+C;IAC3C,IAAIZ,GAAG,GAAGS,IAAI,CAACG,CAAD,CAAd;IACA,IAAIG,WAAW,GAAGlB,qBAAqB,CAACC,eAAD,EAAkBC,MAAlB,EAA0BC,GAA1B,EAA+BC,MAA/B,CAAvC;;IACA,IAAIW,CAAC,KAAK,CAAV,EAAa;MACT,IAAKD,KAAK,IAAII,WAAV,IAA2B,CAACJ,KAAD,IAAU,CAACI,WAA1C,EAAwD;QACpD,OAAO,KAAP;MACH;IACJ,CAJD,MAKK;MACD,IAAKJ,KAAK,IAAI,CAACI,WAAX,IAA4B,CAACJ,KAAD,IAAUI,WAA1C,EAAwD;QACpD,OAAO,KAAP;MACH;IACJ;;IACDhB,MAAM,GAAGC,GAAT;EACH;;EACD,OAAO,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASgB,uBAAT,CAAiClB,eAAjC,EAAkDC,MAAlD,EAA0DkB,KAA1D,EAAiEhB,MAAjE,EAAyES,SAAzE,EAAoF;EACvF,KAAK,IAAIE,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGI,KAAK,CAACH,MAA3B,EAAmCF,CAAC,GAAGC,EAAvC,EAA2C,EAAED,CAA7C,EAAgD;IAC5C,IAAIH,IAAI,GAAGQ,KAAK,CAACL,CAAD,CAAhB;;IACA,IAAI,CAACJ,sBAAsB,CAACV,eAAD,EAAkBC,MAAlB,EAA0BU,IAA1B,EAAgCR,MAAhC,EAAwCS,SAAxC,CAA3B,EAA+E;MAC3E,OAAO,KAAP;IACH;;IACD,IAAID,IAAI,CAACK,MAAT,EAAiB;MACbf,MAAM,GAAGU,IAAI,CAACA,IAAI,CAACK,MAAL,GAAc,CAAf,CAAb;IACH;EACJ;;EACD,OAAO,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,iBAAT,CAA2BpB,eAA3B,EAA4CC,MAA5C,EAAoDU,IAApD,EAA0DR,MAA1D,EAAkES,SAAlE,EAA6E;EAChF,IAAIC,KAAK,GAAGD,SAAS,KAAKH,SAAd,GAA0BG,SAA1B,GAAsC,KAAlD;;EACA,KAAK,IAAIE,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,IAAI,CAACK,MAA1B,EAAkCF,CAAC,GAAGC,EAAtC,EAA0C,EAAED,CAA5C,EAA+C;IAC3C,IAAIZ,GAAG,GAAGS,IAAI,CAACG,CAAD,CAAd;IACA,IAAIG,WAAW,GAAGlB,qBAAqB,CAACC,eAAD,EAAkBC,MAAlB,EAA0BC,GAA1B,EAA+BC,MAA/B,CAAvC;IACA,IAAIkB,OAAO,GAAGP,CAAC,KAAK,CAAN,GACPD,KAAK,IAAII,WAAV,IAA2B,CAACJ,KAAD,IAAU,CAACI,WAD9B,GAEPJ,KAAK,IAAI,CAACI,WAAX,IAA4B,CAACJ,KAAD,IAAUI,WAF5C;;IAGA,IAAII,OAAJ,EAAa;MACTvB,kBAAkB,CAACE,eAAD,EAAkBC,MAAlB,EAA0BC,GAA1B,EAA+BC,MAA/B,CAAlB;IACH;;IACDF,MAAM,GAAGC,GAAT;EACH;;EACD,OAAOD,MAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASqB,sBAAT,CAAgCtB,eAAhC,EAAiDC,MAAjD,EAAyDkB,KAAzD,EAAgEhB,MAAhE,EAAwES,SAAxE,EAAmF;EACtF,KAAK,IAAIE,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGI,KAAK,CAACH,MAA3B,EAAmCF,CAAC,GAAGC,EAAvC,EAA2C,EAAED,CAA7C,EAAgD;IAC5Cb,MAAM,GAAGmB,iBAAiB,CAACpB,eAAD,EAAkBC,MAAlB,EAA0BkB,KAAK,CAACL,CAAD,CAA/B,EAAoCX,MAApC,EAA4CS,SAA5C,CAA1B;EACH;;EACD,OAAOX,MAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASsB,WAAT,CAAqBvB,eAArB,EAAsCW,IAAtC,EAA4C;EAC/C,IAAIQ,KAAK,GAAG,EAAZ;EACA,IAAIlB,MAAM,GAAG,CAAb;EACA,IAAIuB,YAAY,GAAG,CAAnB;;EACA,KAAK,IAAIV,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,IAAI,CAACK,MAA1B,EAAkCF,CAAC,GAAGC,EAAtC,EAA0C,EAAED,CAA5C,EAA+C;IAC3C,IAAIZ,GAAG,GAAGS,IAAI,CAACG,CAAD,CAAd,CAD2C,CAE3C;;IACA,IAAI,CAACf,qBAAqB,CAACC,eAAD,EAAkBC,MAAlB,EAA0BC,GAA1B,EAA+B,CAA/B,CAA1B,EAA6D;MACzDiB,KAAK,CAACM,IAAN,CAAWd,IAAI,CAACe,KAAL,CAAWF,YAAX,EAAyBV,CAAC,GAAG,CAA7B,CAAX;IACH,CAFD,MAGK;MACD,IAAIK,KAAK,CAACH,MAAN,KAAiB,CAArB,EAAwB;QACpB;MACH;;MACDG,KAAK,CAACA,KAAK,CAACH,MAAN,GAAe,CAAhB,CAAL,CAAwBS,IAAxB,CAA6Bd,IAAI,CAACa,YAAD,CAAjC;IACH;;IACDA,YAAY,GAAGV,CAAC,GAAG,CAAnB;IACAb,MAAM,GAAGC,GAAT;EACH;;EACD,OAAOiB,KAAP;AACH"},"metadata":{},"sourceType":"module"}