{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/TileLayer\n */\n\n\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { IMAGE_SMOOTHING_DISABLED, IMAGE_SMOOTHING_ENABLED } from './common.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse, toString as toTransformString } from '../../transform.js';\nimport { assign } from '../../obj.js';\nimport { containsCoordinate, createEmpty, equals, getHeight, getIntersection, getRotatedViewport, getTopLeft, getWidth, intersects } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toSize } from '../../size.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\n\nvar CanvasTileLayerRenderer =\n/** @class */\nfunction (_super) {\n  __extends(CanvasTileLayerRenderer, _super);\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n\n\n  function CanvasTileLayerRenderer(tileLayer) {\n    var _this = _super.call(this, tileLayer) || this;\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n\n\n    _this.extentChanged = true;\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n\n    _this.renderedExtent_ = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.renderedPixelRatio;\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n\n    _this.renderedProjection = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.renderedRevision;\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n\n    _this.renderedTiles = [];\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.newTiles_ = false;\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    _this.tmpExtent = createEmpty();\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n\n    _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    var tileLayer = this.getLayer();\n    var tileState = tile.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var projection = frameState.viewState.projection;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n\n    return tile;\n  };\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getData = function (pixel) {\n    var frameState = this.frameState;\n\n    if (!frameState) {\n      return null;\n    }\n\n    var layer = this.getLayer();\n    var coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    var layerExtent = layer.getExtent();\n\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    var pixelRatio = frameState.pixelRatio;\n    var projection = frameState.viewState.projection;\n    var viewState = frameState.viewState;\n    var source = layer.getRenderSource();\n    var tileGrid = source.getTileGridForProjection(viewState.projection);\n    var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);\n\n      if (!(tile instanceof ImageTile || tile instanceof ReprojTile)) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      var tileOrigin = tileGrid.getOrigin(z);\n      var tileSize = toSize(tileGrid.getTileSize(z));\n      var tileResolution = tileGrid.getResolution(z);\n      var col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n      var row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n      var gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  };\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);\n    }\n\n    return false;\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    return !!this.getLayer().getSource();\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var rotation = viewState.rotation;\n    var pixelRatio = frameState.pixelRatio;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var extent = frameState.extent;\n    var resolution = frameState.viewState.resolution;\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio); // desired dimensions of the canvas in pixels\n\n    var width = Math.round(getWidth(extent) / resolution * pixelRatio);\n    var height = Math.round(getHeight(extent) / resolution * pixelRatio);\n    var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n\n    if (layerExtent) {\n      extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n    }\n\n    var dx = tileResolution * width / 2 / tilePixelRatio;\n    var dy = tileResolution * height / 2 / tilePixelRatio;\n    var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    var viewport = rotation ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size) : undefined;\n\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n          continue;\n        }\n\n        var tile = this.getTile(z, x, y, frameState);\n\n        if (this.isDrawableTile(tile)) {\n          var uid = getUid(this);\n\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n\n    var canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio; // set forward and inverse pixel transforms\n\n    composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n    var canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    var context = this.context;\n    var canvas = context.canvas;\n    makeInverse(this.inversePixelTransform, this.pixelTransform); // set scale transform for calculating tile positions on the canvas\n\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      assign(context, IMAGE_SMOOTHING_DISABLED);\n    }\n\n    this.preRender(context, frameState);\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n\n    var zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var clips, clipZs, currentClip;\n\n    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n\n    for (var i = zs.length - 1; i >= 0; --i) {\n      var currentZ = zs[i];\n      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      var currentResolution = tileGrid.getResolution(currentZ);\n      var currentScale = currentResolution / tileResolution;\n      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;\n      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;\n      var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      var origin_1 = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      var tilesToDraw = tilesToDrawByZ[currentZ];\n\n      for (var tileCoordKey in tilesToDraw) {\n        var tile =\n        /** @type {import(\"../../ImageTile.js\").default} */\n        tilesToDraw[tileCoordKey];\n        var tileCoord = tile.tileCoord; // Calculate integer positions and sizes so that tiles align\n\n        var xIndex = originTileCoord[1] - tileCoord[1];\n        var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);\n        var yIndex = originTileCoord[2] - tileCoord[2];\n        var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);\n        var x = Math.round(origin_1[0] - xIndex * dx_1);\n        var y = Math.round(origin_1[1] - yIndex * dy_1);\n        var w = nextX - x;\n        var h = nextY - y;\n        var transition = z === currentZ;\n        var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        var contextSaved = false;\n\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n\n            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {\n              if (z !== currentZ && currentZ < clipZs[i_1]) {\n                var clip = clips[i_1];\n\n                if (intersects([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n\n                  context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile\n\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n\n        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);\n\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n\n    assign(context, IMAGE_SMOOTHING_ENABLED);\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  };\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition) {\n    var image = this.getTileImage(tile);\n\n    if (!image) {\n      return;\n    }\n\n    var uid = getUid(this);\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    var alphaChanged = alpha !== this.context.globalAlpha;\n\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getImage = function () {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage();\n  };\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function (tileSource, map, frameState) {\n        var tileSourceKey = getUid(tileSource);\n\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n      /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */\n      postRenderFunction);\n    }\n  };\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    var tileSourceKey = getUid(tileSource);\n\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  };\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {\n    var tileSourceKey = getUid(tileSource);\n\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var rotation = frameState.viewState.rotation;\n    var viewport = rotation ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;\n    var tileCount = 0;\n    var tile, tileRange, tileResolution, x, y, z;\n\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n            continue;\n          }\n\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n\n    tileSource.updateCacheSize(tileCount, projection);\n  };\n\n  return CanvasTileLayerRenderer;\n}(CanvasLayerRenderer);\n\nexport default CanvasTileLayerRenderer;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","CanvasLayerRenderer","ImageTile","ReprojTile","TileRange","TileState","IMAGE_SMOOTHING_DISABLED","IMAGE_SMOOTHING_ENABLED","apply","applyTransform","compose","composeTransform","makeInverse","toString","toTransformString","assign","containsCoordinate","createEmpty","equals","getHeight","getIntersection","getRotatedViewport","getTopLeft","getWidth","intersects","fromUserExtent","getUid","numberSafeCompareFunction","toSize","CanvasTileLayerRenderer","_super","tileLayer","_this","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","isDrawableTile","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","getTile","z","x","y","frameState","pixelRatio","projection","viewState","tileSource","getSource","setState","getPreload","getInterimTile","getData","pixel","layer","coordinate","pixelToCoordinateTransform","slice","layerExtent","getExtent","source","getRenderSource","tileGrid","getTileGridForProjection","tilePixelRatio","getTilePixelRatio","getZForResolution","resolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","getResolution","col","Math","floor","row","gutter","round","getGutterForProjection","getImageData","getImage","loadedTileCallback","tiles","zoom","prepareFrame","renderFrame","target","layerState","layerStatesArray","layerIndex","viewResolution","viewCenter","center","rotation","sourceRevision","getRevision","zDirection","extent","width","height","dx","dy","canvasExtent","tileRange","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","viewport","size","undefined","minX","maxX","minY","maxY","tileCoordIntersectsViewport","uid","inTransition","opacity","endTransition","indexOf","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","pixelTransform","canvasTransform","useContainer","getBackground","context","canvas","inversePixelTransform","tempTransform","containerReused","clearRect","clipUnrotated","getInterpolate","preRender","length","zs","keys","map","Number","sort","clips","clipZs","currentClip","getOpaque","reverse","i","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","dx_1","dy_1","originTileCoord","originTileExtent","getTileCoordExtent","origin_1","tileGutter","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","i_1","ii","clip","save","beginPath","moveTo","lineTo","push","drawTileImage","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","manageTilePyramid","scheduleExpireCache","postRender","style","transform","container","image","getTileImage","alpha","alphaChanged","globalAlpha","drawImage","animate","canExpireCache","postRenderFunction","tileSourceKey","expireCache","bind","postRenderFunctions","getKey","preload","opt_tileCallback","wantedTiles","tileQueue","minZoom","tileCount","IDLE","isKeyQueued","enqueue","getTileCoordCenter","useTile","updateCacheSize"],"sources":["/home/asura/github/smartcity/source/node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { IMAGE_SMOOTHING_DISABLED, IMAGE_SMOOTHING_ENABLED } from './common.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse, toString as toTransformString, } from '../../transform.js';\nimport { assign } from '../../obj.js';\nimport { containsCoordinate, createEmpty, equals, getHeight, getIntersection, getRotatedViewport, getTopLeft, getWidth, intersects, } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toSize } from '../../size.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nvar CanvasTileLayerRenderer = /** @class */ (function (_super) {\n    __extends(CanvasTileLayerRenderer, _super);\n    /**\n     * @param {LayerType} tileLayer Tile layer.\n     */\n    function CanvasTileLayerRenderer(tileLayer) {\n        var _this = _super.call(this, tileLayer) || this;\n        /**\n         * Rendered extent has changed since the previous `renderFrame()` call\n         * @type {boolean}\n         */\n        _this.extentChanged = true;\n        /**\n         * @private\n         * @type {?import(\"../../extent.js\").Extent}\n         */\n        _this.renderedExtent_ = null;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.renderedPixelRatio;\n        /**\n         * @protected\n         * @type {import(\"../../proj/Projection.js\").default}\n         */\n        _this.renderedProjection = null;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.renderedRevision;\n        /**\n         * @protected\n         * @type {!Array<import(\"../../Tile.js\").default>}\n         */\n        _this.renderedTiles = [];\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.newTiles_ = false;\n        /**\n         * @protected\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.tmpExtent = createEmpty();\n        /**\n         * @private\n         * @type {import(\"../../TileRange.js\").default}\n         */\n        _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n        return _this;\n    }\n    /**\n     * @protected\n     * @param {import(\"../../Tile.js\").default} tile Tile.\n     * @return {boolean} Tile is drawable.\n     */\n    CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n        var tileLayer = this.getLayer();\n        var tileState = tile.getState();\n        var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n        return (tileState == TileState.LOADED ||\n            tileState == TileState.EMPTY ||\n            (tileState == TileState.ERROR && !useInterimTilesOnError));\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {!import(\"../../Tile.js\").default} Tile.\n     */\n    CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n        var pixelRatio = frameState.pixelRatio;\n        var projection = frameState.viewState.projection;\n        var tileLayer = this.getLayer();\n        var tileSource = tileLayer.getSource();\n        var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n        if (tile.getState() == TileState.ERROR) {\n            if (!tileLayer.getUseInterimTilesOnError()) {\n                // When useInterimTilesOnError is false, we consider the error tile as loaded.\n                tile.setState(TileState.LOADED);\n            }\n            else if (tileLayer.getPreload() > 0) {\n                // Preloaded tiles for lower resolutions might have finished loading.\n                this.newTiles_ = true;\n            }\n        }\n        if (!this.isDrawableTile(tile)) {\n            tile = tile.getInterimTile();\n        }\n        return tile;\n    };\n    /**\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @return {Uint8ClampedArray} Data at the pixel location.\n     */\n    CanvasTileLayerRenderer.prototype.getData = function (pixel) {\n        var frameState = this.frameState;\n        if (!frameState) {\n            return null;\n        }\n        var layer = this.getLayer();\n        var coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n        var layerExtent = layer.getExtent();\n        if (layerExtent) {\n            if (!containsCoordinate(layerExtent, coordinate)) {\n                return null;\n            }\n        }\n        var pixelRatio = frameState.pixelRatio;\n        var projection = frameState.viewState.projection;\n        var viewState = frameState.viewState;\n        var source = layer.getRenderSource();\n        var tileGrid = source.getTileGridForProjection(viewState.projection);\n        var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n        for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n            var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n            var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);\n            if (!(tile instanceof ImageTile || tile instanceof ReprojTile)) {\n                return null;\n            }\n            if (tile.getState() !== TileState.LOADED) {\n                continue;\n            }\n            var tileOrigin = tileGrid.getOrigin(z);\n            var tileSize = toSize(tileGrid.getTileSize(z));\n            var tileResolution = tileGrid.getResolution(z);\n            var col = Math.floor(tilePixelRatio *\n                ((coordinate[0] - tileOrigin[0]) / tileResolution -\n                    tileCoord[1] * tileSize[0]));\n            var row = Math.floor(tilePixelRatio *\n                ((tileOrigin[1] - coordinate[1]) / tileResolution -\n                    tileCoord[2] * tileSize[1]));\n            var gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n            return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n        }\n        return null;\n    };\n    /**\n     * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n     * @param {number} zoom Zoom level.\n     * @param {import(\"../../Tile.js\").default} tile Tile.\n     * @return {boolean|void} If `false`, the tile will not be considered loaded.\n     */\n    CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n        if (this.isDrawableTile(tile)) {\n            return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);\n        }\n        return false;\n    };\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n        return !!this.getLayer().getSource();\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {HTMLElement} target Target that may be used to render content to.\n     * @return {HTMLElement} The rendered element.\n     */\n    CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var viewState = frameState.viewState;\n        var projection = viewState.projection;\n        var viewResolution = viewState.resolution;\n        var viewCenter = viewState.center;\n        var rotation = viewState.rotation;\n        var pixelRatio = frameState.pixelRatio;\n        var tileLayer = this.getLayer();\n        var tileSource = tileLayer.getSource();\n        var sourceRevision = tileSource.getRevision();\n        var tileGrid = tileSource.getTileGridForProjection(projection);\n        var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n        var tileResolution = tileGrid.getResolution(z);\n        var extent = frameState.extent;\n        var resolution = frameState.viewState.resolution;\n        var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n        // desired dimensions of the canvas in pixels\n        var width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n        var height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n        var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n        if (layerExtent) {\n            extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n        }\n        var dx = (tileResolution * width) / 2 / tilePixelRatio;\n        var dy = (tileResolution * height) / 2 / tilePixelRatio;\n        var canvasExtent = [\n            viewCenter[0] - dx,\n            viewCenter[1] - dy,\n            viewCenter[0] + dx,\n            viewCenter[1] + dy,\n        ];\n        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n        /**\n         * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n         */\n        var tilesToDrawByZ = {};\n        tilesToDrawByZ[z] = {};\n        var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n        var tmpExtent = this.tmpExtent;\n        var tmpTileRange = this.tmpTileRange_;\n        this.newTiles_ = false;\n        var viewport = rotation\n            ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size)\n            : undefined;\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                if (rotation &&\n                    !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n                    continue;\n                }\n                var tile = this.getTile(z, x, y, frameState);\n                if (this.isDrawableTile(tile)) {\n                    var uid = getUid(this);\n                    if (tile.getState() == TileState.LOADED) {\n                        tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n                        var inTransition = tile.inTransition(uid);\n                        if (inTransition && layerState.opacity !== 1) {\n                            // Skipping transition when layer is not fully opaque avoids visual artifacts.\n                            tile.endTransition(uid);\n                            inTransition = false;\n                        }\n                        if (!this.newTiles_ &&\n                            (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n                            this.newTiles_ = true;\n                        }\n                    }\n                    if (tile.getAlpha(uid, frameState.time) === 1) {\n                        // don't look for alt tiles if alpha is 1\n                        continue;\n                    }\n                }\n                var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n                var covered = false;\n                if (childTileRange) {\n                    covered = findLoadedTiles(z + 1, childTileRange);\n                }\n                if (!covered) {\n                    tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n                }\n            }\n        }\n        var canvasScale = ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n        // set forward and inverse pixel transforms\n        composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n        var canvasTransform = toTransformString(this.pixelTransform);\n        this.useContainer(target, canvasTransform, this.getBackground(frameState));\n        var context = this.context;\n        var canvas = context.canvas;\n        makeInverse(this.inversePixelTransform, this.pixelTransform);\n        // set scale transform for calculating tile positions on the canvas\n        composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n        if (canvas.width != width || canvas.height != height) {\n            canvas.width = width;\n            canvas.height = height;\n        }\n        else if (!this.containerReused) {\n            context.clearRect(0, 0, width, height);\n        }\n        if (layerExtent) {\n            this.clipUnrotated(context, frameState, layerExtent);\n        }\n        if (!tileSource.getInterpolate()) {\n            assign(context, IMAGE_SMOOTHING_DISABLED);\n        }\n        this.preRender(context, frameState);\n        this.renderedTiles.length = 0;\n        /** @type {Array<number>} */\n        var zs = Object.keys(tilesToDrawByZ).map(Number);\n        zs.sort(numberSafeCompareFunction);\n        var clips, clipZs, currentClip;\n        if (layerState.opacity === 1 &&\n            (!this.containerReused ||\n                tileSource.getOpaque(frameState.viewState.projection))) {\n            zs = zs.reverse();\n        }\n        else {\n            clips = [];\n            clipZs = [];\n        }\n        for (var i = zs.length - 1; i >= 0; --i) {\n            var currentZ = zs[i];\n            var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n            var currentResolution = tileGrid.getResolution(currentZ);\n            var currentScale = currentResolution / tileResolution;\n            var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;\n            var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;\n            var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n            var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n            var origin_1 = applyTransform(this.tempTransform, [\n                (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n                    tileResolution,\n                (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n                    tileResolution,\n            ]);\n            var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n            var tilesToDraw = tilesToDrawByZ[currentZ];\n            for (var tileCoordKey in tilesToDraw) {\n                var tile = /** @type {import(\"../../ImageTile.js\").default} */ (tilesToDraw[tileCoordKey]);\n                var tileCoord = tile.tileCoord;\n                // Calculate integer positions and sizes so that tiles align\n                var xIndex = originTileCoord[1] - tileCoord[1];\n                var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);\n                var yIndex = originTileCoord[2] - tileCoord[2];\n                var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);\n                var x = Math.round(origin_1[0] - xIndex * dx_1);\n                var y = Math.round(origin_1[1] - yIndex * dy_1);\n                var w = nextX - x;\n                var h = nextY - y;\n                var transition = z === currentZ;\n                var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n                var contextSaved = false;\n                if (!inTransition) {\n                    if (clips) {\n                        // Clip mask for regions in this tile that already filled by a higher z tile\n                        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n                        for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {\n                            if (z !== currentZ && currentZ < clipZs[i_1]) {\n                                var clip = clips[i_1];\n                                if (intersects([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n                                    if (!contextSaved) {\n                                        context.save();\n                                        contextSaved = true;\n                                    }\n                                    context.beginPath();\n                                    // counter-clockwise (outer ring) for current tile\n                                    context.moveTo(currentClip[0], currentClip[1]);\n                                    context.lineTo(currentClip[2], currentClip[3]);\n                                    context.lineTo(currentClip[4], currentClip[5]);\n                                    context.lineTo(currentClip[6], currentClip[7]);\n                                    // clockwise (inner ring) for higher z tile\n                                    context.moveTo(clip[6], clip[7]);\n                                    context.lineTo(clip[4], clip[5]);\n                                    context.lineTo(clip[2], clip[3]);\n                                    context.lineTo(clip[0], clip[1]);\n                                    context.clip();\n                                }\n                            }\n                        }\n                        clips.push(currentClip);\n                        clipZs.push(currentZ);\n                    }\n                    else {\n                        context.clearRect(x, y, w, h);\n                    }\n                }\n                this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);\n                if (clips && !inTransition) {\n                    if (contextSaved) {\n                        context.restore();\n                    }\n                    this.renderedTiles.unshift(tile);\n                }\n                else {\n                    this.renderedTiles.push(tile);\n                }\n                this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n            }\n        }\n        this.renderedRevision = sourceRevision;\n        this.renderedResolution = tileResolution;\n        this.extentChanged =\n            !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n        this.renderedExtent_ = canvasExtent;\n        this.renderedPixelRatio = pixelRatio;\n        this.renderedProjection = projection;\n        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n        this.scheduleExpireCache(frameState, tileSource);\n        this.postRender(context, frameState);\n        if (layerState.extent) {\n            context.restore();\n        }\n        assign(context, IMAGE_SMOOTHING_ENABLED);\n        if (canvasTransform !== canvas.style.transform) {\n            canvas.style.transform = canvasTransform;\n        }\n        return this.container;\n    };\n    /**\n     * @param {import(\"../../ImageTile.js\").default} tile Tile.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} x Left of the tile.\n     * @param {number} y Top of the tile.\n     * @param {number} w Width of the tile.\n     * @param {number} h Height of the tile.\n     * @param {number} gutter Tile gutter.\n     * @param {boolean} transition Apply an alpha transition.\n     */\n    CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition) {\n        var image = this.getTileImage(tile);\n        if (!image) {\n            return;\n        }\n        var uid = getUid(this);\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var alpha = layerState.opacity *\n            (transition ? tile.getAlpha(uid, frameState.time) : 1);\n        var alphaChanged = alpha !== this.context.globalAlpha;\n        if (alphaChanged) {\n            this.context.save();\n            this.context.globalAlpha = alpha;\n        }\n        this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n        if (alphaChanged) {\n            this.context.restore();\n        }\n        if (alpha !== layerState.opacity) {\n            frameState.animate = true;\n        }\n        else if (transition) {\n            tile.endTransition(uid);\n        }\n    };\n    /**\n     * @return {HTMLCanvasElement} Image\n     */\n    CanvasTileLayerRenderer.prototype.getImage = function () {\n        var context = this.context;\n        return context ? context.canvas : null;\n    };\n    /**\n     * Get the image from a tile.\n     * @param {import(\"../../ImageTile.js\").default} tile Tile.\n     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {\n        return tile.getImage();\n    };\n    /**\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {\n        if (tileSource.canExpireCache()) {\n            /**\n             * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n             * @param {import(\"../../PluggableMap.js\").default} map Map.\n             * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n             */\n            var postRenderFunction = function (tileSource, map, frameState) {\n                var tileSourceKey = getUid(tileSource);\n                if (tileSourceKey in frameState.usedTiles) {\n                    tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n                }\n            }.bind(null, tileSource);\n            frameState.postRenderFunctions.push(\n            /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */ (postRenderFunction));\n        }\n    };\n    /**\n     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @param {import('../../Tile.js').default} tile Tile.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {\n        // FIXME should we use tilesToDrawByZ instead?\n        var tileSourceKey = getUid(tileSource);\n        if (!(tileSourceKey in usedTiles)) {\n            usedTiles[tileSourceKey] = {};\n        }\n        usedTiles[tileSourceKey][tile.getKey()] = true;\n    };\n    /**\n     * Manage tile pyramid.\n     * This function performs a number of functions related to the tiles at the\n     * current zoom and lower zoom levels:\n     * - registers idle tiles in frameState.wantedTiles so that they are not\n     *   discarded by the tile queue\n     * - enqueues missing tiles\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @param {number} currentZ Current Z.\n     * @param {number} preload Load low resolution tiles up to `preload` levels.\n     * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {\n        var tileSourceKey = getUid(tileSource);\n        if (!(tileSourceKey in frameState.wantedTiles)) {\n            frameState.wantedTiles[tileSourceKey] = {};\n        }\n        var wantedTiles = frameState.wantedTiles[tileSourceKey];\n        var tileQueue = frameState.tileQueue;\n        var minZoom = tileGrid.getMinZoom();\n        var rotation = frameState.viewState.rotation;\n        var viewport = rotation\n            ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size)\n            : undefined;\n        var tileCount = 0;\n        var tile, tileRange, tileResolution, x, y, z;\n        for (z = minZoom; z <= currentZ; ++z) {\n            tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n            tileResolution = tileGrid.getResolution(z);\n            for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n                for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                    if (rotation &&\n                        !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n                        continue;\n                    }\n                    if (currentZ - z <= preload) {\n                        ++tileCount;\n                        tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n                        if (tile.getState() == TileState.IDLE) {\n                            wantedTiles[tile.getKey()] = true;\n                            if (!tileQueue.isKeyQueued(tile.getKey())) {\n                                tileQueue.enqueue([\n                                    tile,\n                                    tileSourceKey,\n                                    tileGrid.getTileCoordCenter(tile.tileCoord),\n                                    tileResolution,\n                                ]);\n                            }\n                        }\n                        if (opt_tileCallback !== undefined) {\n                            opt_tileCallback(tile);\n                        }\n                    }\n                    else {\n                        tileSource.useTile(z, x, y, projection);\n                    }\n                }\n            }\n        }\n        tileSource.updateCacheSize(tileCount, projection);\n    };\n    return CanvasTileLayerRenderer;\n}(CanvasLayerRenderer));\nexport default CanvasTileLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}