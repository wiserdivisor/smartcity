{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/geom/Polygon\n */\n\n\nimport GeometryLayout from './GeometryLayout.js';\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY, getCenter } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray } from './flat/interiorpoint.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingArray } from './flat/intersectsextent.js';\nimport { linearRingsAreOriented, orientLinearRings } from './flat/orient.js';\nimport { linearRings as linearRingsArea } from './flat/area.js';\nimport { linearRingsContainsXY } from './flat/contains.js';\nimport { modulo } from '../math.js';\nimport { quantizeArray } from './flat/simplify.js';\nimport { offset as sphereOffset } from '../sphere.js';\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\n\nvar Polygon =\n/** @class */\nfunction (_super) {\n  __extends(Polygon, _super);\n  /**\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n   *     Array of linear rings that define the polygon. The first linear ring of the\n   *     array defines the outer-boundary or surface of the polygon. Each subsequent\n   *     linear ring defines a hole in the surface of the polygon. A linear ring is\n   *     an array of vertices' coordinates where the first coordinate and the last are\n   *     equivalent. (For internal use, flat coordinates in combination with\n   *     `opt_layout` and `opt_ends` are also accepted.)\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @param {Array<number>} [opt_ends] Ends (for internal use with flat coordinates).\n   */\n\n\n  function Polygon(coordinates, opt_layout, opt_ends) {\n    var _this = _super.call(this) || this;\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n\n    _this.ends_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.flatInteriorPointRevision_ = -1;\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n\n    _this.flatInteriorPoint_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.maxDeltaRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.orientedRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    _this.orientedFlatCoordinates_ = null;\n\n    if (opt_layout !== undefined && opt_ends) {\n      _this.setFlatCoordinates(opt_layout,\n      /** @type {Array<number>} */\n      coordinates);\n\n      _this.ends_ = opt_ends;\n    } else {\n      _this.setCoordinates(\n      /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */\n      coordinates, opt_layout);\n    }\n\n    return _this;\n  }\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {LinearRing} linearRing Linear ring.\n   * @api\n   */\n\n\n  Polygon.prototype.appendLinearRing = function (linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Polygon} Clone.\n   * @api\n   */\n\n\n  Polygon.prototype.clone = function () {\n    var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n    polygon.applyProperties(this);\n    return polygon;\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n\n\n  Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n\n\n  Polygon.prototype.containsXY = function (x, y) {\n    return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n  };\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n\n\n  Polygon.prototype.getArea = function () {\n    return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n  };\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n\n\n  Polygon.prototype.getCoordinates = function (opt_right) {\n    var flatCoordinates;\n\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n  };\n  /**\n   * @return {Array<number>} Ends.\n   */\n\n\n  Polygon.prototype.getEnds = function () {\n    return this.ends_;\n  };\n  /**\n   * @return {Array<number>} Interior point.\n   */\n\n\n  Polygon.prototype.getFlatInteriorPoint = function () {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      var flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n\n    return this.flatInteriorPoint_;\n  };\n  /**\n   * Return an interior point of the polygon.\n   * @return {Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n\n\n  Polygon.prototype.getInteriorPoint = function () {\n    return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n  };\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRingCount = function () {\n    return this.ends_.length;\n  };\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {LinearRing|null} Linear ring.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRing = function (index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n\n    return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array<LinearRing>} Linear rings.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRings = function () {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var linearRings = [];\n    var offset = 0;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);\n      linearRings.push(linearRing);\n      offset = end;\n    }\n\n    return linearRings;\n  };\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n\n\n  Polygon.prototype.getOrientedFlatCoordinates = function () {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n      }\n\n      this.orientedRevision_ = this.getRevision();\n    }\n\n    return this.orientedFlatCoordinates_;\n  };\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Polygon} Simplified Polygon.\n   * @protected\n   */\n\n\n  Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n\n\n  Polygon.prototype.getType = function () {\n    return 'Polygon';\n  };\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n\n\n  Polygon.prototype.intersectsExtent = function (extent) {\n    return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n  };\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @api\n   */\n\n\n  Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return Polygon;\n}(SimpleGeometry);\n\nexport default Polygon;\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [opt_n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [opt_sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\n\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n  var n = opt_n ? opt_n : 32;\n  /** @type {Array<number>} */\n\n  var flatCoordinates = [];\n\n  for (var i = 0; i < n; ++i) {\n    extend(flatCoordinates, sphereOffset(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));\n  }\n\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n}\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\n\nexport function fromExtent(extent) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n}\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [opt_sides] Number of sides of the polygon. Default is 32.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\n\nexport function fromCircle(circle, opt_sides, opt_angle) {\n  var sides = opt_sides ? opt_sides : 32;\n  var stride = circle.getStride();\n  var layout = circle.getLayout();\n  var center = circle.getCenter();\n  var arrayLength = stride * (sides + 1);\n  var flatCoordinates = new Array(arrayLength);\n\n  for (var i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n\n    for (var j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n\n  var ends = [flatCoordinates.length];\n  var polygon = new Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), opt_angle);\n  return polygon;\n}\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\n\nexport function makeRegular(polygon, center, radius, opt_angle) {\n  var flatCoordinates = polygon.getFlatCoordinates();\n  var stride = polygon.getStride();\n  var sides = flatCoordinates.length / stride - 1;\n  var startAngle = opt_angle ? opt_angle : 0;\n\n  for (var i = 0; i <= sides; ++i) {\n    var offset = i * stride;\n    var angle = startAngle + modulo(i, sides) * 2 * Math.PI / sides;\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n  }\n\n  polygon.changed();\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","GeometryLayout","LinearRing","Point","SimpleGeometry","arrayMaxSquaredDelta","assignClosestArrayPoint","closestSquaredDistanceXY","getCenter","deflateCoordinatesArray","extend","getInteriorPointOfArray","inflateCoordinatesArray","intersectsLinearRingArray","linearRingsAreOriented","orientLinearRings","linearRings","linearRingsArea","linearRingsContainsXY","modulo","quantizeArray","offset","sphereOffset","Polygon","_super","coordinates","opt_layout","opt_ends","_this","ends_","flatInteriorPointRevision_","flatInteriorPoint_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","undefined","setFlatCoordinates","setCoordinates","appendLinearRing","linearRing","flatCoordinates","getFlatCoordinates","slice","push","length","changed","clone","polygon","layout","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","containsXY","getOrientedFlatCoordinates","getArea","getCoordinates","opt_right","getEnds","getFlatInteriorPoint","flatCenter","getInteriorPoint","XYM","getLinearRingCount","getLinearRing","index","getLinearRings","ends","i","ii","end","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEnds","XY","getType","intersectsExtent","extent","setLayout","circular","center","radius","opt_n","opt_sphereRadius","n","PI","fromExtent","minX","minY","maxX","maxY","fromCircle","circle","opt_sides","opt_angle","sides","getStride","getLayout","arrayLength","j","makeRegular","getRadius","startAngle","angle","cos","sin"],"sources":["/home/asura/github/smartcity/source/node_modules/ol/geom/Polygon.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Polygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY, getCenter } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray } from './flat/interiorpoint.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingArray } from './flat/intersectsextent.js';\nimport { linearRingsAreOriented, orientLinearRings } from './flat/orient.js';\nimport { linearRings as linearRingsArea } from './flat/area.js';\nimport { linearRingsContainsXY } from './flat/contains.js';\nimport { modulo } from '../math.js';\nimport { quantizeArray } from './flat/simplify.js';\nimport { offset as sphereOffset } from '../sphere.js';\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nvar Polygon = /** @class */ (function (_super) {\n    __extends(Polygon, _super);\n    /**\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n     *     Array of linear rings that define the polygon. The first linear ring of the\n     *     array defines the outer-boundary or surface of the polygon. Each subsequent\n     *     linear ring defines a hole in the surface of the polygon. A linear ring is\n     *     an array of vertices' coordinates where the first coordinate and the last are\n     *     equivalent. (For internal use, flat coordinates in combination with\n     *     `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<number>} [opt_ends] Ends (for internal use with flat coordinates).\n     */\n    function Polygon(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatInteriorPointRevision_ = -1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.flatInteriorPoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.orientedFlatCoordinates_ = null;\n        if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linear ring to this polygon.\n     * @param {LinearRing} linearRing Linear ring.\n     * @api\n     */\n    Polygon.prototype.appendLinearRing = function (linearRing) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Polygon} Clone.\n     * @api\n     */\n    Polygon.prototype.clone = function () {\n        var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        polygon.applyProperties(this);\n        return polygon;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Polygon.prototype.containsXY = function (x, y) {\n        return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n    };\n    /**\n     * Return the area of the polygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    Polygon.prototype.getArea = function () {\n        return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n    };\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for polygons.\n     *\n     * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    Polygon.prototype.getCoordinates = function (opt_right) {\n        var flatCoordinates;\n        if (opt_right !== undefined) {\n            flatCoordinates = this.getOrientedFlatCoordinates().slice();\n            orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n        }\n        else {\n            flatCoordinates = this.flatCoordinates;\n        }\n        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    Polygon.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * @return {Array<number>} Interior point.\n     */\n    Polygon.prototype.getFlatInteriorPoint = function () {\n        if (this.flatInteriorPointRevision_ != this.getRevision()) {\n            var flatCenter = getCenter(this.getExtent());\n            this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n            this.flatInteriorPointRevision_ = this.getRevision();\n        }\n        return this.flatInteriorPoint_;\n    };\n    /**\n     * Return an interior point of the polygon.\n     * @return {Point} Interior point as XYM coordinate, where M is the\n     * length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n    Polygon.prototype.getInteriorPoint = function () {\n        return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n    };\n    /**\n     * Return the number of rings of the polygon,  this includes the exterior\n     * ring and any interior rings.\n     *\n     * @return {number} Number of rings.\n     * @api\n     */\n    Polygon.prototype.getLinearRingCount = function () {\n        return this.ends_.length;\n    };\n    /**\n     * Return the Nth linear ring of the polygon geometry. Return `null` if the\n     * given index is out of range.\n     * The exterior linear ring is available at index `0` and the interior rings\n     * at index `1` and beyond.\n     *\n     * @param {number} index Index.\n     * @return {LinearRing|null} Linear ring.\n     * @api\n     */\n    Polygon.prototype.getLinearRing = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linear rings of the polygon.\n     * @return {Array<LinearRing>} Linear rings.\n     * @api\n     */\n    Polygon.prototype.getLinearRings = function () {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var linearRings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);\n            linearRings.push(linearRing);\n            offset = end;\n        }\n        return linearRings;\n    };\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n    Polygon.prototype.getOrientedFlatCoordinates = function () {\n        if (this.orientedRevision_ != this.getRevision()) {\n            var flatCoordinates = this.flatCoordinates;\n            if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n                this.orientedFlatCoordinates_ = flatCoordinates;\n            }\n            else {\n                this.orientedFlatCoordinates_ = flatCoordinates.slice();\n                this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n            }\n            this.orientedRevision_ = this.getRevision();\n        }\n        return this.orientedFlatCoordinates_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {Polygon} Simplified Polygon.\n     * @protected\n     */\n    Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    Polygon.prototype.getType = function () {\n        return 'Polygon';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Polygon.prototype.intersectsExtent = function (extent) {\n        return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the polygon.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return Polygon;\n}(SimpleGeometry));\nexport default Polygon;\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [opt_n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [opt_sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n    var n = opt_n ? opt_n : 32;\n    /** @type {Array<number>} */\n    var flatCoordinates = [];\n    for (var i = 0; i < n; ++i) {\n        extend(flatCoordinates, sphereOffset(center, radius, (2 * Math.PI * i) / n, opt_sphereRadius));\n    }\n    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n    return new Polygon(flatCoordinates, GeometryLayout.XY, [\n        flatCoordinates.length,\n    ]);\n}\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var flatCoordinates = [\n        minX,\n        minY,\n        minX,\n        maxY,\n        maxX,\n        maxY,\n        maxX,\n        minY,\n        minX,\n        minY,\n    ];\n    return new Polygon(flatCoordinates, GeometryLayout.XY, [\n        flatCoordinates.length,\n    ]);\n}\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [opt_sides] Number of sides of the polygon. Default is 32.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, opt_sides, opt_angle) {\n    var sides = opt_sides ? opt_sides : 32;\n    var stride = circle.getStride();\n    var layout = circle.getLayout();\n    var center = circle.getCenter();\n    var arrayLength = stride * (sides + 1);\n    var flatCoordinates = new Array(arrayLength);\n    for (var i = 0; i < arrayLength; i += stride) {\n        flatCoordinates[i] = 0;\n        flatCoordinates[i + 1] = 0;\n        for (var j = 2; j < stride; j++) {\n            flatCoordinates[i + j] = center[j];\n        }\n    }\n    var ends = [flatCoordinates.length];\n    var polygon = new Polygon(flatCoordinates, layout, ends);\n    makeRegular(polygon, center, circle.getRadius(), opt_angle);\n    return polygon;\n}\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, opt_angle) {\n    var flatCoordinates = polygon.getFlatCoordinates();\n    var stride = polygon.getStride();\n    var sides = flatCoordinates.length / stride - 1;\n    var startAngle = opt_angle ? opt_angle : 0;\n    for (var i = 0; i <= sides; ++i) {\n        var offset = i * stride;\n        var angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\n        flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n        flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n    }\n    polygon.changed();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}